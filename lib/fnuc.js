// Generated by CoffeeScript 1.9.3
(function() {
  var ARITY, CHAINABLE, I, _, _firstthenable, _fold, _foldr, _isthenable, _promapply, _toString, aand, add, all, any, arity, arityof, binary, builtin, chainable, clone, compose, concat, contains, curry, div, drop, each, eq, eql, evolve, exports, expose, filter, firstfn, flip, fold, fold1, foldr, foldr1, get, groupby, gt, gte, has, head, ident, index, indexfn, isplain, join, keys, last, lastfn, lcase, len, lt, lte, map, match, max, merge, min, minifyNot, mixin, mod, mul, ncurry, nnot, ofilter, omap, oor, partial, partialr, pick, plift, replace, reverse, search, sequence, set, shallow, slice, sort, split, sub, tail, take, tap, ternary, trim, type, typeis, ucase, unary, uncurry, uniq, uniqfn, values, zip, zipwith,
    slice1 = [].slice;

  minifyNot = function() {};

  ARITY = [
    function(z) {
      return function() {
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a) {
        minifyNot(a);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b) {
        minifyNot(a, b);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c) {
        minifyNot(a, b, c);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d) {
        minifyNot(a, b, c, d);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e) {
        minifyNot(a, b, c, d, e);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f) {
        minifyNot(a, b, c, d, e, f);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f, g) {
        minifyNot(a, b, c, d, e, f, g);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f, g, h) {
        minifyNot(a, b, c, d, e, f, g, h);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f, g, h, i) {
        minifyNot(a, b, c, d, e, f, g, h, i);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f, g, h, i, j) {
        minifyNot(a, b, c, d, e, f, g, h, i, j);
        return z.apply(null, arguments);
      };
    }
  ];

  I = ident = function(a) {
    return a;
  };

  builtin = I.bind.bind(I.call);

  _toString = builtin(Object.prototype.toString);

  shallow = function(a) {
    var i, q, r, ref, ref1, t;
    if (!a) {
      return a;
    }
    r = null;
    if ((ref = (t = type(a))) === 'string' || ref === 'number' || ref === 'boolean' || ref === 'symbol') {
      r = a;
    } else if (t === 'array') {
      r = [];
      for (i = q = 0, ref1 = a.length; q < ref1; i = q += 1) {
        r[i] = a[i];
      }
    } else if (t === 'date') {
      r = new Date(a.getTime());
    } else if (isplain(a)) {
      r = merge({}, a);
    } else {
      throw new TypeError("Can't shallow " + a);
    }
    return r;
  };

  clone = function(a) {
    var i, k, q, ref, s, v;
    if (!a) {
      return a;
    }
    s = shallow(a);
    if (type(a) === 'array') {
      for (i = q = 0, ref = a.length; q < ref; i = q += 1) {
        s[i] = clone(s[i]);
      }
    } else if (isplain(s)) {
      for (k in s) {
        v = s[k];
        s[k] = clone(v);
      }
    }
    return s;
  };

  isplain = function(o) {
    return !!o && typeof o === 'object' && o.constructor === Object;
  };

  type = function(a) {
    return _toString(a).slice(8, -1).toLowerCase();
  };

  merge = function() {
    var k, len1, o, os, q, t, v;
    t = arguments[0], os = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    for (q = 0, len1 = os.length; q < len1; q++) {
      o = os[q];
      for (k in o) {
        v = o[k];
        t[k] = v;
      }
    }
    return t;
  };

  mixin = function() {
    var os;
    os = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return merge.apply(null, [{}].concat(slice1.call(os)));
  };

  head = function(a) {
    return a[0];
  };

  tail = function(a) {
    return a.slice(1);
  };

  last = function(a) {
    return a[a.length - 1];
  };

  arity = function(f, n) {
    var ar;
    if (arguments.length === 1) {
      n = f;
      f = void 0;
    }
    ar = ARITY[n];
    if (f) {
      return ar(f);
    } else {
      return ar;
    }
  };

  arityof = function(f) {
    if (type(f) === 'function') {
      return f.length;
    }
  };

  unary = arity(1);

  binary = arity(2);

  ternary = arity(3);

  ncurry = function(n, v, f, as) {
    var l, nf;
    if (as == null) {
      as = [];
    }
    l = n - as.length;
    nf = arity(l)(function() {
      var bs, cs;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      cs = (bs.length <= l ? bs : (v ? bs : bs.slice(0, l))).concat(as);
      if (cs.length < n) {
        return ncurry(n, v, f, cs);
      } else {
        return f.apply(null, cs);
      }
    });
    Object.defineProperty(nf, '_curry', {
      value: function() {
        return partialr.apply(null, [f].concat(slice1.call(as)));
      }
    });
    return nf;
  };

  curry = function(f) {
    var n, nf;
    n = arityof(f);
    if (n < 2) {
      return f;
    }
    nf = arity(n)(function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      if (as.length < n) {
        return ncurry(n, false, f, as);
      } else {
        return f.apply(null, as);
      }
    });
    Object.defineProperty(nf, '_curry', {
      value: function() {
        return f;
      }
    });
    return nf;
  };

  uncurry = function(f) {
    if (f._curry) {
      return f._curry();
    } else {
      return f;
    }
  };

  partial = function() {
    var as, f, n;
    f = arguments[0], as = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    if ((n = arityof(f) - as.length) <= 0) {
      return f.apply(null, as);
    }
    return arity(n)(function() {
      var bs;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return f.apply(null, as.concat(bs));
    });
  };

  partialr = function() {
    var as, f, n;
    f = arguments[0], as = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    if ((n = arityof(f) - as.length) <= 0) {
      return f.apply(null, as);
    }
    return arity(n)(function() {
      var bs;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return f.apply(null, bs.slice(0, n).concat(as));
    });
  };

  flip = function(f) {
    var g, rewrap;
    if (f._flip) {
      return f._flip;
    }
    rewrap = f._curry ? curry : I;
    g = rewrap(arity(arityof(f))(function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return uncurry(f).apply(null, as.reverse());
    }));
    Object.defineProperty(g, '_flip', {
      value: f
    });
    return g;
  };

  compose = function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return ncurry(arityof(last(fs)), false, fold1(fs, function(f, g) {
      return function() {
        var as;
        as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
        return f(g.apply(null, as));
      };
    }));
  };

  sequence = flip(compose);

  tap = curry(function(a, f) {
    f(a);
    return a;
  });

  typeis = curry(function(a, s) {
    return type(a) === s;
  });

  all = curry(binary(builtin(Array.prototype.every)));

  any = curry(binary(builtin(Array.prototype.some)));

  contains = curry(function(as, a) {
    return index(as, a) >= 0;
  });

  concat = function() {
    var as, ref;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return (ref = []).concat.apply(ref, as);
  };

  each = curry(binary(builtin(Array.prototype.forEach)));

  filter = curry(binary(function(as, f) {
    var len1, q, r, ri, v;
    r = [];
    ri = -1;
    for (q = 0, len1 = as.length; q < len1; q++) {
      v = as[q];
      if (f(v)) {
        r[++ri] = v;
      }
    }
    return r;
  }));

  _fold = function(as, f, acc, arrInit) {
    var i, len;
    i = 0;
    len = as.length;
    if (arrInit) {
      acc = as[i++];
    }
    for (;i < len; ++i) { acc = f(acc,as[i]) };
    return acc;
  };

  _foldr = function(as, f, acc, arrInit) {
    var i;
    i = as.length;
    if (arrInit) {
      acc = as[--i];
    }
    while (i--) { acc = f(acc,as[i]) };
    return acc;
  };

  fold = curry(function(as, f, v) {
    return _fold(as, f, v, false);
  });

  fold1 = curry(function(as, f) {
    return _fold(as, f, null, true);
  });

  foldr = curry(function(as, f, v) {
    return _foldr(as, f, v, false);
  });

  foldr1 = curry(function(as, f) {
    return _foldr(as, f, null, true);
  });

  index = curry(binary(function(as, v, fr) {
    return indexfn(as, eq(v), fr);
  }));

  indexfn = curry(binary(function(as, fn, fr) {
    var i, len;
    len = (as != null ? as.length : void 0) || 0;
    if (!len) {
      return -1;
    }
    i = fr || 0;
    for (;i < len; ++i) { if (fn(as[i])) return i };
    return -1;
  }));

  firstfn = curry(binary(function(as, fn, fr) {
    var i, len, r;
    r = null;
    len = (as != null ? as.length : void 0) || 0;
    if (!len) {
      return null;
    }
    i = fr || 0;
    for (;i < len; ++i) { if (fn(r = as[i])) return r };
    return null;
  }));

  lastfn = curry(binary(function(as, fn, fr) {
    var i, r;
    r = null;
    i = fr || ((as != null ? as.length : void 0) - 1);
    if (!(i < (as != null ? as.length : void 0))) {
      return null;
    }
    for (;i >= 0; --i) { if (fn(r = as[i])) return r };
    return null;
  }));

  join = curry(binary(builtin(Array.prototype.join)));

  map = curry(function(as, f) {
    var i, len, r;
    r = Array(as.length);
    len = as.length;
    i = 0;
    for (;i < len; ++i) { r[i] = f(as[i]) };
    return r;
  });

  reverse = unary(builtin(Array.prototype.reverse));

  sort = curry(binary(builtin(Array.prototype.sort)));

  uniqfn = curry(function(as, fn) {
    var fned;
    if (!as) {
      return as;
    }
    fned = map(as, fn);
    return as.filter(function(v, i) {
      return index(fned, fned[i]) === i;
    });
  });

  uniq = function(as) {
    if (!as) {
      return as;
    }
    return as.filter(function(v, i) {
      return index(as, v) === i;
    });
  };

  _isthenable = function(p) {
    var ref;
    if (!p) {
      return false;
    }
    if ((ref = typeof p) !== 'object' && ref !== 'function') {
      return false;
    }
    return typeof p.then === 'function';
  };

  _firstthenable = sequence(firstfn(_isthenable), function(p) {
    return p != null ? p.then.bind(p) : void 0;
  });

  _promapply = function(pfn, parg) {
    var fn;
    fn = null;
    return pfn.then(function(_fn) {
      fn = _fn;
      return parg;
    }).then(function(arg) {
      return fn(arg);
    });
  };

  plift = function(f) {
    return arity(arityof(f))(function() {
      var as, t0;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      t0 = _firstthenable(as);
      if (t0) {
        return foldr(as, _promapply, t0(function() {
          return ncurry(as.length, false, f);
        }));
      } else {
        return f.apply(null, as);
      }
    });
  };

  has = curry(function(o, k) {
    return o.hasOwnProperty(k);
  });

  get = curry(function(o, k) {
    return o[k];
  });

  set = curry(function(o, k, v) {
    o[k] = v;
    return o;
  });

  keys = function(o) {
    return Object.keys(o);
  };

  values = function(o) {
    return map(keys(o), function(k) {
      return o[k];
    });
  };

  omap = curry(function(o, f) {
    var k, r, v;
    r = {};
    for (k in o) {
      v = o[k];
      r[k] = f(k, v);
    }
    return r;
  });

  ofilter = curry(function(o, f) {
    var k, r, v;
    r = {};
    for (k in o) {
      v = o[k];
      if (f(k, v)) {
        r[k] = v;
      }
    }
    return r;
  });

  evolve = curry(function(o, t) {
    return omap(o, function(k, v) {
      if (has(t, k)) {
        return t[k](v);
      } else {
        return v;
      }
    });
  });

  pick = curry(binary(function() {
    var as, k, len1, o, q, r;
    o = arguments[0], as = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    if (typeis(as[0], 'array')) {
      as = as[0];
    }
    r = {};
    for (q = 0, len1 = as.length; q < len1; q++) {
      k = as[q];
      r[k] = o[k];
    }
    return r;
  }));

  split = curry(binary(builtin(String.prototype.split)));

  match = curry(binary(builtin(String.prototype.match)));

  replace = curry(ternary(builtin(String.prototype.replace)));

  search = curry(binary(builtin(String.prototype.search)));

  trim = unary(builtin(String.prototype.trim));

  ucase = unary(builtin(String.prototype.toUpperCase));

  lcase = unary(builtin(String.prototype.toLowerCase));

  slice = curry(function(s, m, n) {
    return s.slice(m, n);
  });

  drop = curry(function(s, n) {
    return s.slice(n);
  });

  take = curry(function(s, n) {
    return s.slice(0, n);
  });

  len = function(t) {
    return t.length;
  };

  add = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a + b;
    });
  }));

  sub = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a - b;
    });
  }));

  mul = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a * b;
    });
  }));

  div = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a / b;
    });
  }));

  mod = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a % b;
    });
  }));

  min = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return Math.min.apply(Math, as);
  }));

  max = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return Math.max.apply(Math, as);
  }));

  gt = curry(function(a, b) {
    return a > b;
  });

  gte = curry(function(a, b) {
    return a >= b;
  });

  lt = curry(function(a, b) {
    return a < b;
  });

  lte = curry(function(a, b) {
    return a <= b;
  });

  _ = {};

  eq = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      if (a === b) {
        return a;
      } else {
        return _;
      }
    }) !== _;
  }));

  aand = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return function() {
      var bs, i;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      len = as.length;
      i = 0;
      for (;i < len; ++i) { if (!as[i].apply(null,bs)) { return false } };
      return true;
    };
  }));

  oor = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return function() {
      var bs, i;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      len = as.length;
      i = 0;
      for (;i < len; ++i) { if (as[i].apply(null,bs)) { return true } };
      return false;
    };
  }));

  nnot = curry(binary(function() {
    var as, f, q;
    as = 2 <= arguments.length ? slice1.call(arguments, 0, q = arguments.length - 1) : (q = 0, []), f = arguments[q++];
    return !f.apply(null, as);
  }));

  zipwith = ncurry(3, true, function() {
    var a, as, f, i, ml, n, q, ref, results, u;
    as = 2 <= arguments.length ? slice1.call(arguments, 0, q = arguments.length - 1) : (q = 0, []), f = arguments[q++];
    ml = min.apply(null, (function() {
      var len1, results, u;
      results = [];
      for (u = 0, len1 = as.length; u < len1; u++) {
        a = as[u];
        results.push(a.length);
      }
      return results;
    })());
    results = [];
    for (i = u = 0, ref = ml; u < ref; i = u += 1) {
      results.push(f.apply(null, (function() {
        var ref1, results1, w;
        results1 = [];
        for (n = w = 0, ref1 = as.length; w < ref1; n = w += 1) {
          results1.push(as[n][i]);
        }
        return results1;
      })()));
    }
    return results;
  });

  zip = zipwith(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return as;
  });

  eql = (function() {
    var eqarr, eqobj, eqplain, eqtype, sortstr;
    eqtype = function(a, b) {
      return type(a) === type(b);
    };
    eqarr = function(a, b) {
      var i, q, ref;
      if (a.length !== b.length) {
        return false;
      }
      for (i = q = 0, ref = a.length; q < ref; i = q += 1) {
        if (!eql(a[i], b[i])) {
          return false;
        }
      }
      return true;
    };
    eqplain = function(a, b) {
      return isplain(a) && isplain(b);
    };
    sortstr = sort(function(s1, s2) {
      return s1.localeCompare(s2);
    });
    eqobj = function(a, b) {
      var k, ka, len1, q;
      ka = sortstr(keys(a));
      if (!eqarr(ka, sortstr(keys(b)))) {
        return false;
      }
      for (q = 0, len1 = ka.length; q < len1; q++) {
        k = ka[q];
        if (!eql(a[k], b[k])) {
          return false;
        }
      }
      return true;
    };
    return curry(function(a, b) {
      if (a === b) {
        return true;
      }
      return (aand(eqtype, (function() {
        switch (type(a)) {
          case 'object':
            return aand(eqplain, eqobj);
          case 'array':
            return eqarr;
          default:
            return function() {
              return false;
            };
        }
      })()))(a, b);
    });
  })();

  groupby = curry(function(as, fn) {
    return fold(as, function(acc, a) {
      var k;
      k = fn(a);
      (acc[k] || (acc[k] = [])).push(a);
      return acc;
    }, {});
  });

  chainable = function(name, f) {
    var g, n;
    n = arityof(f);
    if (n < 1) {
      throw new Error("No chainable for arity 0");
    }
    g = f._curry ? f : curry(f);
    Object.defineProperty(Function.prototype, name, {
      configurable: true,
      get: function() {
        var p;
        p = this;
        if (n === 1) {
          return sequence(p, g);
        } else {
          return curry(arity(n - 1)(function() {
            var as;
            as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
            return sequence(p, g.apply(null, as));
          }));
        }
      }
    });
    return null;
  };

  exports = {
    shallow: shallow,
    clone: clone,
    type: type,
    typeis: typeis,
    isplain: isplain,
    arity: arity,
    arityof: arityof,
    unary: unary,
    binary: binary,
    ternary: ternary,
    curry: curry,
    flip: flip,
    compose: compose,
    sequence: sequence,
    I: I,
    ident: ident,
    partial: partial,
    partialr: partialr,
    tap: tap,
    chainable: chainable,
    merge: merge,
    mixin: mixin,
    has: has,
    get: get,
    set: set,
    keys: keys,
    values: values,
    pick: pick,
    evolve: evolve,
    omap: omap,
    ofilter: ofilter,
    eql: eql,
    groupby: groupby,
    concat: concat,
    head: head,
    tail: tail,
    last: last,
    fold: fold,
    fold1: fold1,
    foldr: foldr,
    foldr1: foldr1,
    each: each,
    map: map,
    filter: filter,
    all: all,
    any: any,
    join: join,
    reverse: reverse,
    sort: sort,
    index: index,
    indexfn: indexfn,
    contains: contains,
    uniq: uniq,
    uniqfn: uniqfn,
    zip: zip,
    zipwith: zipwith,
    len: len,
    firstfn: firstfn,
    lastfn: lastfn,
    split: split,
    match: match,
    replace: replace,
    search: search,
    trim: trim,
    ucase: ucase,
    lcase: lcase,
    slice: slice,
    drop: drop,
    take: take,
    add: add,
    sub: sub,
    mul: mul,
    div: div,
    mod: mod,
    min: min,
    max: max,
    gt: gt,
    gte: gte,
    lt: lt,
    lte: lte,
    eq: eq,
    aand: aand,
    oor: oor,
    nnot: nnot,
    plift: plift
  };

  exports.and = exports.aand;

  exports.or = exports.oor;

  exports.not = exports.nnot;

  CHAINABLE = split('clone shallow flip tap has get set keys values concat head tail last lastfn firstfn fold fold1 foldr foldr1 each map filter all any join reverse sort index indexfn contains uniq uniqfn split match replace search slice, drop, take, trim ucase lcase add sub mul div mod min max gt gte lt lte eq and or not eql groupby', ' ');

  exports.installChainable = function() {
    each(CHAINABLE, function(name) {
      return chainable(name, exports[name]);
    });
    return exports;
  };

  expose = function(exp, guard) {
    return function() {
      var funs, k, len1, obj, q, v;
      obj = arguments[0], funs = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
      if (funs != null ? funs.length : void 0) {
        for (q = 0, len1 = funs.length; q < len1; q++) {
          k = funs[q];
          obj[k] = exp[k];
        }
      } else if (!obj[guard]) {
        for (k in exp) {
          v = exp[k];
          if (k.indexOf("_") !== 0) {
            obj[k] = v;
          }
        }
        obj[guard] = true;
      }
      return exp;
    };
  };

  exports.expose = expose(exports, '__fnuc');

  if (typeof module === 'object') {
    module.exports = exports;
  } else if (typeof define === 'function' && define.amd) {
    define(function() {
      return exports;
    });
  } else {
    this.F = exports;
  }

}).call(this);

//# sourceMappingURL=fnuc.js.map
