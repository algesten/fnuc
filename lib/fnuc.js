// Generated by CoffeeScript 1.8.0
(function() {
  var ARITY, CHAINABLE, I, Tuple, aand, add, all, any, arity, binary, builtin, chainable, clone, compose, concat, contains, curry, div, drop, each, eq, eql, evolve, exports, expose, filter, flip, fold, fold1, foldr, foldr1, fst, get, groupby, gt, gte, has, head, ident, index, isplain, join, keys, last, lcase, len, lt, lte, map, match, max, merge, min, minifyNot, mixin, mod, mul, ncurry, nnot, nth, ofilter, omap, oor, partial, partialr, pick, replace, reverse, search, sequence, set, shallow, slice, snd, sort, split, sub, tail, take, tap, ternary, trim, tuple, type, typeis, ucase, unary, uncurry, uniq, unpack, unzip, values, zip, zipwith, _, _fold, _foldr, _toString,
    __slice = [].slice;

  minifyNot = function() {};

  ARITY = [
    function(z) {
      return function() {
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a) {
        minifyNot(a);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b) {
        minifyNot(a, b);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c) {
        minifyNot(a, b, c);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d) {
        minifyNot(a, b, c, d);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e) {
        minifyNot(a, b, c, d, e);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f) {
        minifyNot(a, b, c, d, e, f);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f, g) {
        minifyNot(a, b, c, d, e, f, g);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f, g, h) {
        minifyNot(a, b, c, d, e, f, g, h);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f, g, h, i) {
        minifyNot(a, b, c, d, e, f, g, h, i);
        return z.apply(null, arguments);
      };
    }, function(z) {
      return function(a, b, c, d, e, f, g, h, i, j) {
        minifyNot(a, b, c, d, e, f, g, h, i, j);
        return z.apply(null, arguments);
      };
    }
  ];

  I = ident = function(a) {
    return a;
  };

  builtin = I.bind.bind(I.call);

  _toString = builtin(Object.prototype.toString);

  shallow = function(a) {
    var i, r, t, _i, _ref, _ref1;
    if (!a) {
      return a;
    }
    r = null;
    if ((_ref = (t = type(a))) === 'string' || _ref === 'number' || _ref === 'boolean' || _ref === 'symbol') {
      r = a;
    } else if (t === 'array') {
      r = [];
      for (i = _i = 0, _ref1 = a.length; _i < _ref1; i = _i += 1) {
        r[i] = a[i];
      }
    } else if (t === 'date') {
      r = new Date(a.getTime());
    } else if (t === 'tuple') {
      r = a.unpack(tuple);
    } else if (isplain(a)) {
      r = merge({}, a);
    } else {
      throw new TypeError("Can't shallow " + a);
    }
    return r;
  };

  clone = function(a) {
    var i, k, s, t, v, _i, _ref;
    if (!a) {
      return a;
    }
    if ((t = type(a)) === 'tuple') {
      s = a.unpack(function() {
        var as;
        as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return tuple.apply(null, clone(as));
      });
    } else {
      s = shallow(a);
      if (t === 'array') {
        for (i = _i = 0, _ref = a.length; _i < _ref; i = _i += 1) {
          s[i] = clone(s[i]);
        }
      } else if (isplain(s)) {
        for (k in s) {
          v = s[k];
          s[k] = clone(v);
        }
      }
    }
    return s;
  };

  isplain = function(o) {
    return !!o && typeof o === 'object' && o.constructor === Object;
  };

  Tuple = function() {};

  type = function(a) {
    if (a instanceof Tuple) {
      return 'tuple';
    } else {
      return _toString(a).slice(8, -1).toLowerCase();
    }
  };

  merge = function() {
    var k, o, os, t, v, _i, _len;
    t = arguments[0], os = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = os.length; _i < _len; _i++) {
      o = os[_i];
      for (k in o) {
        v = o[k];
        if (v !== void 0) {
          t[k] = v;
        }
      }
    }
    return t;
  };

  mixin = function() {
    var os;
    os = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return merge.apply(null, [{}].concat(__slice.call(os)));
  };

  head = function(a) {
    return a[0];
  };

  tail = function(a) {
    return a.slice(1);
  };

  last = function(a) {
    return a[a.length - 1];
  };

  arity = function(f, n) {
    var _ar;
    if (arguments.length === 1) {
      if (type(f) === 'function') {
        return f.length;
      }
      n = f;
      f = void 0;
    }
    _ar = function(f) {
      return ARITY[n](f);
    };
    if (f) {
      return _ar(f);
    } else {
      return _ar;
    }
  };

  unary = arity(1);

  binary = arity(2);

  ternary = arity(3);

  ncurry = function(n, v, f, as) {
    var l, nf;
    if (as == null) {
      as = [];
    }
    l = n - as.length;
    nf = arity(l)(function() {
      var bs, cs;
      bs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      cs = (bs.length <= l ? bs : (v ? bs : bs.slice(0, l))).concat(as);
      if (cs.length < n) {
        return ncurry(n, v, f, cs);
      } else {
        return f.apply(null, cs);
      }
    });
    Object.defineProperty(nf, '_curry', {
      value: function() {
        return partialr.apply(null, [f].concat(__slice.call(as)));
      }
    });
    return nf;
  };

  curry = function(f) {
    var n, nf;
    n = arity(f);
    if (n < 2) {
      return f;
    }
    nf = arity(n)(function() {
      var as;
      as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (as.length < n) {
        return ncurry(n, false, f, as);
      } else {
        return f.apply(null, as);
      }
    });
    Object.defineProperty(nf, '_curry', {
      value: function() {
        return f;
      }
    });
    return nf;
  };

  uncurry = function(f) {
    if (f._curry) {
      return f._curry();
    } else {
      return f;
    }
  };

  partial = function() {
    var as, f, n;
    f = arguments[0], as = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((n = arity(f) - as.length) <= 0) {
      return f.apply(null, as);
    }
    return arity(n)(function() {
      var bs;
      bs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f.apply(null, as.concat(bs));
    });
  };

  partialr = function() {
    var as, f, n;
    f = arguments[0], as = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((n = arity(f) - as.length) <= 0) {
      return f.apply(null, as);
    }
    return arity(n)(function() {
      var bs;
      bs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f.apply(null, bs.slice(0, n).concat(as));
    });
  };

  flip = function(f) {
    var g, rewrap;
    if (f._flip) {
      return f._flip;
    }
    rewrap = f._curry ? curry : I;
    g = rewrap(arity(arity(f))(function() {
      var as;
      as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return uncurry(f).apply(null, as.reverse());
    }));
    Object.defineProperty(g, '_flip', {
      value: f
    });
    return g;
  };

  compose = function() {
    var fs;
    fs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return ncurry(arity(last(fs)), false, fold1(fs, function(f, g) {
      return function() {
        var as;
        as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return f(g.apply(null, as));
      };
    }));
  };

  sequence = flip(compose);

  tap = curry(function(a, f) {
    f(a);
    return a;
  });

  typeis = curry(function(a, s) {
    return type(a) === s;
  });

  all = curry(binary(builtin(Array.prototype.every)));

  any = curry(binary(builtin(Array.prototype.some)));

  contains = curry(function(as, a) {
    return index(as, a) >= 0;
  });

  concat = curry(binary(function() {
    var as, _ref;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref = []).concat.apply(_ref, as);
  }));

  each = curry(binary(builtin(Array.prototype.forEach)));

  filter = curry(binary(function(as, f) {
    var r, ri, v, _i, _len;
    r = [];
    ri = -1;
    for (_i = 0, _len = as.length; _i < _len; _i++) {
      v = as[_i];
      if (f(v)) {
        r[++ri] = v;
      }
    }
    return r;
  }));

  _fold = function(as, f, acc, arrInit) {
    var i, len;
    i = 0;
    len = as.length;
    if (arrInit) {
      acc = as[i++];
    }
    for (;i < len; ++i) { acc = f(acc,as[i]) };
    return acc;
  };

  _foldr = function(as, f, acc, arrInit) {
    var i;
    i = as.length;
    if (arrInit) {
      acc = as[--i];
    }
    while (i--) { acc = f(acc,as[i]) };
    return acc;
  };

  fold = curry(function(as, f, v) {
    return _fold(as, f, v, false);
  });

  fold1 = curry(function(as, f) {
    return _fold(as, f, null, true);
  });

  foldr = curry(function(as, f, v) {
    return _foldr(as, f, v, false);
  });

  foldr1 = curry(function(as, f) {
    return _foldr(as, f, null, true);
  });

  index = curry(binary(function(as, v, fr) {
    var i, len;
    len = (as != null ? as.length : void 0) || 0;
    if (!len) {
      return -1;
    }
    i = fr || 0;
    for (;i < len; ++i) { if (as[i] == v) return i };
    return -1;
  }));

  join = curry(binary(builtin(Array.prototype.join)));

  map = curry(function(as, f) {
    var i, len, r;
    r = Array(as.length);
    len = as.length;
    i = 0;
    for (;i < len; ++i) { r[i] = f(as[i]) };
    return r;
  });

  reverse = unary(builtin(Array.prototype.reverse));

  sort = curry(binary(builtin(Array.prototype.sort)));

  uniq = function(as) {
    if (!as) {
      return as;
    }
    return as.filter(function(v, i) {
      return index(as, v) === i;
    });
  };

  has = curry(function(o, k) {
    return o.hasOwnProperty(k);
  });

  get = curry(function(o, k) {
    return o[k];
  });

  set = curry(function(o, k, v) {
    o[k] = v;
    return o;
  });

  keys = function(o) {
    return Object.keys(o);
  };

  values = function(o) {
    return map(keys(o), function(k) {
      return o[k];
    });
  };

  omap = curry(function(o, f) {
    var k, r, v;
    r = {};
    for (k in o) {
      v = o[k];
      r[k] = f(k, v);
    }
    return r;
  });

  ofilter = curry(function(o, f) {
    var k, r, v;
    r = {};
    for (k in o) {
      v = o[k];
      if (f(k, v)) {
        r[k] = v;
      }
    }
    return r;
  });

  evolve = curry(function(o, t) {
    return omap(o, function(k, v) {
      if (has(t, k)) {
        return t[k](v);
      } else {
        return v;
      }
    });
  });

  pick = curry(binary(function() {
    var as, k, o, r, _i, _len;
    o = arguments[0], as = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (typeis(as[0], 'array')) {
      as = as[0];
    }
    r = {};
    for (_i = 0, _len = as.length; _i < _len; _i++) {
      k = as[_i];
      r[k] = o[k];
    }
    return r;
  }));

  split = curry(binary(builtin(String.prototype.split)));

  match = curry(binary(builtin(String.prototype.match)));

  replace = curry(ternary(builtin(String.prototype.replace)));

  search = curry(binary(builtin(String.prototype.search)));

  trim = unary(builtin(String.prototype.trim));

  ucase = unary(builtin(String.prototype.toUpperCase));

  lcase = unary(builtin(String.prototype.toLowerCase));

  slice = curry(function(s, m, n) {
    return s.slice(m, n);
  });

  drop = curry(function(s, n) {
    return s.slice(n);
  });

  take = curry(function(s, n) {
    return s.slice(0, n);
  });

  add = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a + b;
    });
  }));

  sub = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a - b;
    });
  }));

  mul = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a * b;
    });
  }));

  div = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a / b;
    });
  }));

  mod = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a % b;
    });
  }));

  min = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return Math.min.apply(Math, as);
  }));

  max = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return Math.max.apply(Math, as);
  }));

  gt = curry(function(a, b) {
    return a > b;
  });

  gte = curry(function(a, b) {
    return a >= b;
  });

  lt = curry(function(a, b) {
    return a < b;
  });

  lte = curry(function(a, b) {
    return a <= b;
  });

  _ = {};

  eq = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      if (a === b) {
        return a;
      } else {
        return _;
      }
    }) !== _;
  }));

  aand = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function() {
      var bs, i, len;
      bs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      len = as.length;
      i = 0;
      for (;i < len; ++i) { if (!as[i].apply(null,bs)) { return false } };
      return true;
    };
  }));

  oor = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function() {
      var bs, i, len;
      bs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      len = as.length;
      i = 0;
      for (;i < len; ++i) { if (as[i].apply(null,bs)) { return true } };
      return false;
    };
  }));

  nnot = curry(binary(function() {
    var as, f, _i;
    as = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), f = arguments[_i++];
    return !f.apply(null, as);
  }));

  Tuple = (function() {
    function Tuple(as) {
      var i, _i, _ref;
      Object.defineProperty(this, '_as', {
        value: as
      });
      for (i = _i = 0, _ref = as.length; _i < _ref; i = _i += 1) {
        Object.defineProperty(this, String(i), {
          value: as[i],
          enumerable: true
        });
      }
      Object.defineProperty(this, 'length', {
        value: as.length
      });
    }

    Tuple.prototype.unpack = function(un) {
      return un.apply(null, this._as);
    };

    Tuple.prototype.toString = function() {
      return "[tuple " + (JSON.stringify(this)) + "]";
    };

    return Tuple;

  })();

  tuple = ncurry(2, true, function() {
    var as;
    as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new Tuple(as);
  });

  unpack = curry(function(t, f) {
    return t.unpack(f);
  });

  fst = function(t) {
    return t.unpack(I);
  };

  snd = function(t) {
    return t.unpack(function(a, b) {
      return b;
    });
  };

  nth = curry(function(t, n) {
    return t.unpack(function() {
      var as;
      as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return as[n];
    });
  });

  len = function(t) {
    return t.length;
  };

  zipwith = ncurry(3, true, function() {
    var a, as, f, i, ml, n, _i, _j, _results;
    as = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), f = arguments[_i++];
    ml = min.apply(null, (function() {
      var _j, _len, _results;
      _results = [];
      for (_j = 0, _len = as.length; _j < _len; _j++) {
        a = as[_j];
        _results.push(a.length);
      }
      return _results;
    })());
    _results = [];
    for (i = _j = 0; _j < ml; i = _j += 1) {
      _results.push(f.apply(null, (function() {
        var _k, _ref, _results1;
        _results1 = [];
        for (n = _k = 0, _ref = as.length; _k < _ref; n = _k += 1) {
          _results1.push(as[n][i]);
        }
        return _results1;
      })()));
    }
    return _results;
  });

  zip = zipwith(tuple);

  unzip = function(z) {
    var i, l, n, r, un, _i, _ref;
    if (!z.length) {
      return [];
    }
    l = len(z[0]);
    r = (function() {
      var _i, _results;
      _results = [];
      for (n = _i = 0; _i < l; n = _i += 1) {
        _results.push(new Array(z.length));
      }
      return _results;
    })();
    un = function(i) {
      return function() {
        var as, _i;
        as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (n = _i = 0; _i < l; n = _i += 1) {
          r[n][i] = as[n];
        }
        return null;
      };
    };
    for (i = _i = 0, _ref = z.length; _i < _ref; i = _i += 1) {
      z[i].unpack(un(i));
    }
    return tuple.apply(null, r);
  };

  eql = (function() {
    var eqarr, eqobj, eqplain, eqtuple, eqtype, sortstr;
    eqtype = function(a, b) {
      return type(a) === type(b);
    };
    eqtuple = function(a, b) {
      return a.unpack(function() {
        var as;
        as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return b.unpack(function() {
          var bs;
          bs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return eql(as, bs);
        });
      });
    };
    eqarr = function(a, b) {
      var i, _i, _ref;
      if (a.length !== b.length) {
        return false;
      }
      for (i = _i = 0, _ref = a.length; _i < _ref; i = _i += 1) {
        if (!eql(a[i], b[i])) {
          return false;
        }
      }
      return true;
    };
    eqplain = function(a, b) {
      return isplain(a) && isplain(b);
    };
    sortstr = sort(function(s1, s2) {
      return s1.localeCompare(s2);
    });
    eqobj = function(a, b) {
      var k, ka, _i, _len;
      ka = sortstr(keys(a));
      if (!eqarr(ka, sortstr(keys(b)))) {
        return false;
      }
      for (_i = 0, _len = ka.length; _i < _len; _i++) {
        k = ka[_i];
        if (!eql(a[k], b[k])) {
          return false;
        }
      }
      return true;
    };
    return curry(function(a, b) {
      if (a === b) {
        return true;
      }
      return (aand(eqtype, (function() {
        switch (type(a)) {
          case 'tuple':
            return eqtuple;
          case 'object':
            return aand(eqplain, eqobj);
          case 'array':
            return eqarr;
          default:
            return function() {
              return false;
            };
        }
      })()))(a, b);
    });
  })();

  groupby = curry(function(as, fn) {
    return fold(as, function(acc, a) {
      var k;
      k = fn(a);
      (acc[k] || (acc[k] = [])).push(a);
      return acc;
    }, {});
  });

  chainable = function(name, f) {
    var g, n;
    n = arity(f);
    if (n < 1) {
      throw new Error("No chainable for arity 0");
    }
    g = f._curry ? f : curry(f);
    Object.defineProperty(Function.prototype, name, {
      configurable: true,
      get: function() {
        var p;
        p = this;
        if (n === 1) {
          return sequence(p, g);
        } else {
          return curry(arity(n - 1)(function() {
            var as;
            as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return sequence(p, g.apply(null, as));
          }));
        }
      }
    });
    return null;
  };

  exports = {
    shallow: shallow,
    clone: clone,
    type: type,
    typeis: typeis,
    isplain: isplain,
    arity: arity,
    unary: unary,
    binary: binary,
    ternary: ternary,
    curry: curry,
    flip: flip,
    compose: compose,
    sequence: sequence,
    I: I,
    ident: ident,
    partial: partial,
    partialr: partialr,
    tap: tap,
    chainable: chainable,
    merge: merge,
    mixin: mixin,
    has: has,
    get: get,
    set: set,
    keys: keys,
    values: values,
    pick: pick,
    evolve: evolve,
    omap: omap,
    ofilter: ofilter,
    eql: eql,
    groupby: groupby,
    concat: concat,
    head: head,
    tail: tail,
    last: last,
    fold: fold,
    fold1: fold1,
    foldr: foldr,
    foldr1: foldr1,
    each: each,
    map: map,
    filter: filter,
    all: all,
    any: any,
    join: join,
    reverse: reverse,
    sort: sort,
    index: index,
    contains: contains,
    uniq: uniq,
    split: split,
    match: match,
    replace: replace,
    search: search,
    trim: trim,
    ucase: ucase,
    lcase: lcase,
    slice: slice,
    drop: drop,
    take: take,
    add: add,
    sub: sub,
    mul: mul,
    div: div,
    mod: mod,
    min: min,
    max: max,
    gt: gt,
    gte: gte,
    lt: lt,
    lte: lte,
    eq: eq,
    aand: aand,
    oor: oor,
    nnot: nnot,
    tuple: tuple,
    unpack: unpack,
    fst: fst,
    snd: snd,
    len: len,
    nth: nth,
    zip: zip,
    unzip: unzip,
    zipwith: zipwith
  };

  exports.and = exports.aand;

  exports.or = exports.oor;

  exports.not = exports.nnot;

  CHAINABLE = split('clone shallow flip tap has get set keys values concat head tail last fold fold1 foldr foldr1 each map filter all any join reverse sort index contains uniq split match replace search slice, drop, take, trim ucase lcase add sub mul div mod min max gt gte lt lte eq and or not eql groupby', ' ');

  exports.installChainable = function() {
    each(CHAINABLE, function(name) {
      return chainable(name, exports[name]);
    });
    return exports;
  };

  expose = function(exp, guard) {
    return function() {
      var funs, k, obj, v, _i, _len;
      obj = arguments[0], funs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (funs != null ? funs.length : void 0) {
        for (_i = 0, _len = funs.length; _i < _len; _i++) {
          k = funs[_i];
          obj[k] = exp[k];
        }
      } else if (!obj[guard]) {
        for (k in exp) {
          v = exp[k];
          if (k.indexOf("_") !== 0) {
            obj[k] = v;
          }
        }
        obj[guard] = true;
      }
      return exp;
    };
  };

  exports.expose = expose(exports, '__fnuc');

  if (typeof module === 'object') {
    module.exports = exports;
  } else if (typeof define === 'function' && define.amd) {
    define(function() {
      return exports;
    });
  } else {
    this.F = exports;
  }

}).call(this);

//# sourceMappingURL=fnuc.js.map
