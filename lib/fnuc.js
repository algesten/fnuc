// Generated by CoffeeScript 1.10.0
(function() {
  var I, _filter, _fold, _foldr, _toString, aand, add, all, any, apply, arity, arityof, asprop, binary, builtin, clone, compose, concat, contains, converge, curry, div, drop, each, eq, eql, evolve, exports, expose, filter, firstfn, flip, fold, fold1, foldr, foldr1, get, groupby, gt, gte, has, head, ident, iif, index, indexfn, isdef, isplain, join, keys, last, lastfn, lcase, len, lt, lte, map, match, max, maybe, merge, min, mixin, mod, mul, ncurry, nnot, ofilter, omap, oor, partial, partialr, pick, pipe, plift, ppipe, replace, reverse, search, set, shallow, slice, sort, split, sub, tail, take, tap, ternary, trim, type, typeis, ucase, unary, uncurry, uniq, uniqfn, values, zip, zipobj, zipwith,
    slice1 = [].slice;

  I = ident = function(a) {
    return a;
  };

  builtin = I.bind.bind(I.call);

  _toString = builtin(Object.prototype.toString);

  shallow = function(a) {
    var i, q, r, ref, ref1, t;
    if (!a) {
      return a;
    }
    r = null;
    if ((ref = (t = type(a))) === 'string' || ref === 'number' || ref === 'boolean' || ref === 'symbol') {
      r = a;
    } else if (t === 'array') {
      r = [];
      for (i = q = 0, ref1 = a.length; q < ref1; i = q += 1) {
        r[i] = a[i];
      }
    } else if (t === 'date') {
      r = new Date(a.getTime());
    } else if (isplain(a)) {
      r = merge({}, a);
    } else {
      throw new TypeError("Can't shallow " + a);
    }
    return r;
  };

  clone = function(a) {
    var i, k, q, ref, s, v;
    if (!a) {
      return a;
    }
    s = shallow(a);
    if (type(a) === 'array') {
      for (i = q = 0, ref = a.length; q < ref; i = q += 1) {
        s[i] = clone(s[i]);
      }
    } else if (isplain(s)) {
      for (k in s) {
        v = s[k];
        s[k] = clone(v);
      }
    }
    return s;
  };

  isplain = function(o) {
    return !!o && typeof o === 'object' && o.constructor === Object;
  };

  isdef = function(o) {
    return o != null;
  };

  type = function(a) {
    return _toString(a).slice(8, -1).toLowerCase();
  };

  merge = function() {
    var k, len1, o, os, q, t, v;
    t = arguments[0], os = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    for (q = 0, len1 = os.length; q < len1; q++) {
      o = os[q];
      for (k in o) {
        v = o[k];
        t[k] = v;
      }
    }
    return t;
  };

  mixin = function() {
    var os;
    os = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return merge.apply(null, [{}].concat(slice1.call(os)));
  };

  head = function(a) {
    return a[0];
  };

  tail = function(a) {
    return a.slice(1);
  };

  last = function(a) {
    return a[a.length - 1];
  };

  arity = (function() {
    var nary;
    nary = function(n, fn) {
      switch (n) {
        case 0:
          return function() {
            return fn.apply(null, arguments);
          };
        case 1:
          return function(a) {
            return fn.apply(null, arguments);
          };
        case 2:
          return function(a, b) {
            return fn.apply(null, arguments);
          };
        case 3:
          return function(a, b, c) {
            return fn.apply(null, arguments);
          };
        case 4:
          return function(a, b, c, d) {
            return fn.apply(null, arguments);
          };
        case 5:
          return function(a, b, c, d, e) {
            return fn.apply(null, arguments);
          };
        case 6:
          return function(a, b, c, d, e, f) {
            return fn.apply(null, arguments);
          };
        case 7:
          return function(a, b, c, d, e, f, g) {
            return fn.apply(null, arguments);
          };
        case 8:
          return function(a, b, c, d, e, f, g, h) {
            return fn.apply(null, arguments);
          };
        case 9:
          return function(a, b, c, d, e, f, g, h, i) {
            return fn.apply(null, arguments);
          };
        case 10:
          return function(a, b, c, d, e, f, g, h, i, j) {
            return fn.apply(null, arguments);
          };
      }
    };
    return function(fn, n) {
      if (arguments.length === 1) {
        n = fn;
        return function(fn) {
          return nary(n, fn);
        };
      } else {
        return nary(n, fn);
      }
    };
  })();

  arityof = function(f) {
    if (typeof f === 'function') {
      return f.length;
    }
  };

  unary = arity(1);

  binary = arity(2);

  ternary = arity(3);

  ncurry = function(n, v, f, as) {
    var l, nf;
    if (as == null) {
      as = [];
    }
    l = n - as.length;
    nf = arity(l)(function() {
      var bs, cs;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      cs = (bs.length <= l ? bs : (v ? bs : bs.slice(0, l))).concat(as);
      if (cs.length < n) {
        return ncurry(n, v, f, cs);
      } else {
        return f.apply(null, cs);
      }
    });
    Object.defineProperty(nf, '__fnuc_curry', {
      value: function() {
        return partialr.apply(null, [f].concat(slice1.call(as)));
      }
    });
    return nf;
  };

  curry = function(f) {
    var n, nf;
    n = arityof(f);
    if (n < 2) {
      return f;
    }
    nf = arity(n)(function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      if (as.length < n) {
        return ncurry(n, false, f, as);
      } else {
        return f.apply(null, as);
      }
    });
    Object.defineProperty(nf, '__fnuc_curry', {
      value: function() {
        return f;
      }
    });
    return nf;
  };

  uncurry = function(f) {
    if (f.__fnuc_curry) {
      return f.__fnuc_curry();
    } else {
      return f;
    }
  };

  partial = function() {
    var as, f, n;
    f = arguments[0], as = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    if ((n = arityof(f) - as.length) <= 0) {
      return f.apply(null, as);
    }
    return arity(n)(function() {
      var bs;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return f.apply(null, as.concat(bs));
    });
  };

  partialr = function() {
    var as, f, n;
    f = arguments[0], as = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    if ((n = arityof(f) - as.length) <= 0) {
      return f.apply(null, as);
    }
    return arity(n)(function() {
      var bs;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return f.apply(null, bs.slice(0, n).concat(as));
    });
  };

  flip = function(f) {
    var g, rewrap;
    if (f.__fnuc_flip) {
      return f.__fnuc_flip;
    }
    rewrap = f.__fnuc_curry ? curry : I;
    g = rewrap(arity(arityof(f))(function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return uncurry(f).apply(null, as.reverse());
    }));
    Object.defineProperty(g, '__fnuc_flip', {
      value: f
    });
    return g;
  };

  compose = function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return ncurry(arityof(last(fs)), false, fold1(fs, function(f, g) {
      return function() {
        var as;
        as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
        return f(g.apply(null, as));
      };
    }));
  };

  pipe = function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return ncurry(arityof(head(fs)), false, foldr1(fs, function(f, g) {
      return function() {
        var as;
        as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
        return f(g.apply(null, as));
      };
    }));
  };

  converge = ncurry(3, true, function() {
    var after, fns;
    after = arguments[0], fns = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    return ncurry(Math.max.apply(Math, fns.map(arityof)), true, function() {
      var args, context;
      args = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      context = this;
      return after.apply(context, map(fns, function(fn) {
        return fn.apply(context, args);
      }));
    });
  });

  typeis = curry(function(a, s) {
    return type(a) === s;
  });

  tap = curry(function(a, f) {
    f(a);
    return a;
  });

  apply = curry(function(args, fn) {
    return fn.apply(this, args);
  });

  iif = curry(function(c, t, f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      if (c.apply(null, as)) {
        return typeof t === "function" ? t.apply(null, as) : void 0;
      } else {
        return typeof f === "function" ? f.apply(null, as) : void 0;
      }
    };
  });

  maybe = function(fn) {
    return unary(function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      if (as.every(isdef)) {
        return fn.apply(null, as);
      }
    });
  };

  all = curry(binary(builtin(Array.prototype.every)));

  any = curry(binary(builtin(Array.prototype.some)));

  contains = curry(function(as, a) {
    return index(as, a) >= 0;
  });

  concat = function() {
    var as, ref;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return (ref = []).concat.apply(ref, as);
  };

  each = curry(binary(builtin(Array.prototype.forEach)));

  filter = curry(binary(function(as, f) {
    var len1, q, r, ri, v;
    r = [];
    ri = -1;
    for (q = 0, len1 = as.length; q < len1; q++) {
      v = as[q];
      if (f(v)) {
        r[++ri] = v;
      }
    }
    return r;
  }));

  _filter = function(as, f) {
    var i, len1, q, r, ri, v;
    r = [];
    ri = -1;
    for (i = q = 0, len1 = as.length; q < len1; i = ++q) {
      v = as[i];
      if (f(v, i)) {
        r[++ri] = v;
      }
    }
    return r;
  };

  _fold = function(as, f, acc, arrInit) {
    var i, len;
    i = 0;
    len = as.length;
    if (arrInit) {
      acc = as[i++];
    }
    for (;i < len; ++i) { acc = f(acc,as[i]) };
    return acc;
  };

  _foldr = function(as, f, acc, arrInit) {
    var i;
    i = as.length;
    if (arrInit) {
      acc = as[--i];
    }
    while (i--) { acc = f(acc,as[i]) };
    return acc;
  };

  fold = curry(function(as, f, v) {
    return _fold(as, f, v, false);
  });

  fold1 = curry(function(as, f) {
    return _fold(as, f, null, true);
  });

  foldr = curry(function(as, f, v) {
    return _foldr(as, f, v, false);
  });

  foldr1 = curry(function(as, f) {
    return _foldr(as, f, null, true);
  });

  index = curry(binary(function(as, v, fr) {
    var i, len;
    len = as.length;
    i = fr ? fr - 1 : -1;
    while (++i < len) { if (as[i] === v) return i };
    return -1;
  }));

  indexfn = curry(binary(function(as, fn, fr) {
    var i, len;
    len = as.length;
    i = fr ? fr - 1 : -1;
    while (++i < len) { if (fn(as[i])) return i };
    return -1;
  }));

  firstfn = curry(binary(function(as, fn, fr) {
    var i, len, r;
    r = null;
    len = (as != null ? as.length : void 0) || 0;
    if (!len) {
      return null;
    }
    i = fr || 0;
    for (;i < len; ++i) { if (fn(r = as[i])) return r };
    return null;
  }));

  lastfn = curry(binary(function(as, fn, fr) {
    var i, r;
    r = null;
    i = fr || ((as != null ? as.length : void 0) - 1);
    if (!(i < (as != null ? as.length : void 0))) {
      return null;
    }
    for (;i >= 0; --i) { if (fn(r = as[i])) return r };
    return null;
  }));

  join = curry(binary(builtin(Array.prototype.join)));

  map = curry(function(as, f) {
    var i, len, r;
    r = Array(as.length);
    len = as.length;
    i = 0;
    for (;i < len; ++i) { r[i] = f(as[i]) };
    return r;
  });

  reverse = unary(builtin(Array.prototype.reverse));

  sort = curry(binary(builtin(Array.prototype.sort)));

  uniqfn = curry(function(as, fn) {
    var fned;
    if (!as) {
      return as;
    }
    fned = map(as, fn);
    return _filter(as, function(v, i) {
      return fned.indexOf(fned[i]) === i;
    });
  });

  uniq = function(as) {
    if (!as) {
      return as;
    }
    return _filter(as, function(v, i) {
      return as.indexOf(v) === i;
    });
  };

  plift = (function() {
    var firstthen, isthenable, promapply, thenbind;
    isthenable = function(p) {
      var ref;
      if (!p) {
        return false;
      }
      if ((ref = typeof p) !== 'object' && ref !== 'function') {
        return false;
      }
      return typeof p.then === 'function';
    };
    thenbind = function(p) {
      return p.then.bind(p);
    };
    firstthen = pipe(firstfn(isthenable), maybe(thenbind));
    promapply = function(pfn, parg) {
      var fn;
      fn = null;
      return pfn.then(function(_fn) {
        fn = _fn;
        return parg;
      }).then(function(arg) {
        return fn(arg);
      });
    };
    return function(f) {
      return arity(arityof(f))(function() {
        var as, t0;
        as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
        t0 = firstthen(as);
        if (t0) {
          return foldr(as, promapply, t0(function() {
            return ncurry(as.length, false, f);
          }));
        } else {
          return f.apply(null, as);
        }
      });
    };
  })();

  ppipe = function() {
    var fns;
    fns = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return pipe.apply(null, map(fns, plift));
  };

  has = curry(function(o, k) {
    return o.hasOwnProperty(k);
  });

  get = curry(function(o, k) {
    return o[k];
  });

  set = curry(function(o, k, v) {
    o[k] = v;
    return o;
  });

  keys = function(o) {
    return Object.keys(o);
  };

  values = function(o) {
    return map(keys(o), function(k) {
      return o[k];
    });
  };

  omap = curry(function(o, f) {
    var k, r, v;
    r = {};
    for (k in o) {
      v = o[k];
      r[k] = f(k, v);
    }
    return r;
  });

  ofilter = curry(function(o, f) {
    var k, r, v;
    r = {};
    for (k in o) {
      v = o[k];
      if (f(k, v)) {
        r[k] = v;
      }
    }
    return r;
  });

  evolve = curry(function(o, t) {
    return omap(o, function(k, v) {
      if (has(t, k)) {
        return t[k](v);
      } else {
        return v;
      }
    });
  });

  pick = curry(binary(function() {
    var as, k, len1, o, q, r;
    o = arguments[0], as = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    if (typeis(as[0], 'array')) {
      as = as[0];
    }
    r = {};
    for (q = 0, len1 = as.length; q < len1; q++) {
      k = as[q];
      r[k] = o[k];
    }
    return r;
  }));

  split = curry(binary(builtin(String.prototype.split)));

  match = curry(binary(builtin(String.prototype.match)));

  replace = curry(ternary(builtin(String.prototype.replace)));

  search = curry(binary(builtin(String.prototype.search)));

  trim = unary(builtin(String.prototype.trim));

  ucase = unary(builtin(String.prototype.toUpperCase));

  lcase = unary(builtin(String.prototype.toLowerCase));

  slice = curry(function(s, m, n) {
    return s.slice(m, n);
  });

  drop = curry(function(s, n) {
    return s.slice(n);
  });

  take = curry(function(s, n) {
    return s.slice(0, n);
  });

  len = function(t) {
    return t.length;
  };

  add = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a + b;
    });
  }));

  sub = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a - b;
    });
  }));

  mul = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a * b;
    });
  }));

  div = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a / b;
    });
  }));

  mod = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fold1(as, function(a, b) {
      return a % b;
    });
  }));

  min = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return Math.min.apply(Math, as);
  }));

  max = curry(binary(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return Math.max.apply(Math, as);
  }));

  gt = curry(function(a, b) {
    return a > b;
  });

  gte = curry(function(a, b) {
    return a >= b;
  });

  lt = curry(function(a, b) {
    return a < b;
  });

  lte = curry(function(a, b) {
    return a <= b;
  });

  eq = (function() {
    var _;
    _ = {};
    return curry(binary(function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return fold1(as, function(a, b) {
        if (a === b) {
          return a;
        } else {
          return _;
        }
      }) !== _;
    }));
  })();

  aand = curry(binary(function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return function() {
      var as, i;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      len = fs.length;
      i = 0;
      for (;i < len; ++i) { if (!fs[i].apply(null,as)) { return false } };
      return true;
    };
  }));

  oor = curry(binary(function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return function() {
      var as, i;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      len = fs.length;
      i = 0;
      for (;i < len; ++i) { if (fs[i].apply(null,as)) { return true } };
      return false;
    };
  }));

  nnot = function(f) {
    return unary(function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return !f.apply(null, as);
    });
  };

  zipwith = ncurry(3, true, function() {
    var a, as, f, i, ml, n, q, ref, results, u;
    as = 2 <= arguments.length ? slice1.call(arguments, 0, q = arguments.length - 1) : (q = 0, []), f = arguments[q++];
    ml = min.apply(null, (function() {
      var len1, results, u;
      results = [];
      for (u = 0, len1 = as.length; u < len1; u++) {
        a = as[u];
        results.push(a.length);
      }
      return results;
    })());
    results = [];
    for (i = u = 0, ref = ml; u < ref; i = u += 1) {
      results.push(f.apply(null, (function() {
        var ref1, results1, w;
        results1 = [];
        for (n = w = 0, ref1 = as.length; w < ref1; n = w += 1) {
          results1.push(as[n][i]);
        }
        return results1;
      })()));
    }
    return results;
  });

  zip = zipwith(function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return as;
  });

  zipobj = (function() {
    var fn;
    fn = function(obj) {
      return zipwith(function(k, v) {
        return set(obj, k, v);
      });
    };
    return function(ks, vs) {
      var ret;
      fn(ret = {})(ks, vs);
      return ret;
    };
  })();

  eql = (function() {
    var eqarr, eqobj, eqplain, eqtype, sortstr;
    eqtype = function(a, b) {
      return type(a) === type(b);
    };
    eqarr = function(a, b) {
      var i, q, ref;
      if (a.length !== b.length) {
        return false;
      }
      for (i = q = 0, ref = a.length; q < ref; i = q += 1) {
        if (!eql(a[i], b[i])) {
          return false;
        }
      }
      return true;
    };
    eqplain = function(a, b) {
      return isplain(a) && isplain(b);
    };
    sortstr = sort(function(s1, s2) {
      return s1.localeCompare(s2);
    });
    eqobj = function(a, b) {
      var k, ka, len1, q;
      ka = sortstr(keys(a));
      if (!eqarr(ka, sortstr(keys(b)))) {
        return false;
      }
      for (q = 0, len1 = ka.length; q < len1; q++) {
        k = ka[q];
        if (!eql(a[k], b[k])) {
          return false;
        }
      }
      return true;
    };
    return curry(function(a, b) {
      if (a === b) {
        return true;
      }
      return (aand(eqtype, (function() {
        switch (type(a)) {
          case 'object':
            return aand(eqplain, eqobj);
          case 'array':
            return eqarr;
          default:
            return function() {
              return false;
            };
        }
      })()))(a, b);
    });
  })();

  groupby = curry(function(as, fn) {
    return fold(as, function(acc, a) {
      var k;
      k = fn(a);
      (acc[k] || (acc[k] = [])).push(a);
      return acc;
    }, {});
  });

  exports = {
    shallow: shallow,
    clone: clone,
    type: type,
    typeis: typeis,
    isplain: isplain,
    isdef: isdef,
    arity: arity,
    arityof: arityof,
    unary: unary,
    binary: binary,
    ternary: ternary,
    curry: curry,
    flip: flip,
    compose: compose,
    pipe: pipe,
    I: I,
    ident: ident,
    partial: partial,
    partialr: partialr,
    tap: tap,
    converge: converge,
    apply: apply,
    iif: iif,
    maybe: maybe,
    merge: merge,
    mixin: mixin,
    has: has,
    get: get,
    set: set,
    keys: keys,
    values: values,
    pick: pick,
    evolve: evolve,
    omap: omap,
    ofilter: ofilter,
    eql: eql,
    groupby: groupby,
    concat: concat,
    head: head,
    tail: tail,
    last: last,
    fold: fold,
    fold1: fold1,
    foldr: foldr,
    foldr1: foldr1,
    each: each,
    map: map,
    filter: filter,
    all: all,
    any: any,
    join: join,
    reverse: reverse,
    sort: sort,
    index: index,
    indexfn: indexfn,
    contains: contains,
    uniq: uniq,
    uniqfn: uniqfn,
    zip: zip,
    zipwith: zipwith,
    len: len,
    firstfn: firstfn,
    lastfn: lastfn,
    zipobj: zipobj,
    split: split,
    match: match,
    replace: replace,
    search: search,
    trim: trim,
    ucase: ucase,
    lcase: lcase,
    slice: slice,
    drop: drop,
    take: take,
    add: add,
    sub: sub,
    mul: mul,
    div: div,
    mod: mod,
    min: min,
    max: max,
    gt: gt,
    gte: gte,
    lt: lt,
    lte: lte,
    eq: eq,
    aand: aand,
    oor: oor,
    nnot: nnot,
    plift: plift,
    ppipe: ppipe
  };

  exports.and = exports.aand;

  exports.or = exports.oor;

  exports.not = exports.nnot;

  asprop = function(fn) {
    return {
      value: fn,
      enumerable: true,
      configurable: false,
      writable: false
    };
  };

  expose = (function() {
    var guard;
    guard = '__fnuc';
    return function(exp) {
      return function(obj) {
        var fns, ks, ofexp, props;
        if (obj[guard]) {
          return;
        }
        ofexp = (flip(get))(exp);
        ks = keys(exp);
        fns = map(ofexp)(ks);
        props = zipobj(ks, map(asprop)(fns));
        Object.defineProperties(obj, props);
        Object.defineProperty(obj, guard, asprop(I));
        return exp;
      };
    };
  })();

  exports.expose = expose(exports);

  if (typeof module === 'object') {
    module.exports = exports;
  } else if (typeof define === 'function' && define.amd) {
    define(function() {
      return exports;
    });
  } else {
    this.F = exports;
  }

}).call(this);

//# sourceMappingURL=fnuc.js.map
