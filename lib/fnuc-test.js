// Generated by CoffeeScript 1.8.0
(function() {
  var F, FN_TEST, Foo, TYPES, TYPE_ARR, TYPE_NO_PROTO, TYPE_PLAIN, TYPE_PROTO, assert, chai, date, expect, foldfn, mock, sandbox, sinon, spy, stub;

  if (typeof browsertest !== "undefined" && browsertest !== null) {
    sinon = window.sinon;
    expect = window.chai.expect;
  } else {
    chai = require('chai');
    chai.should();
    expect = chai.expect;
    chai.use(require('sinon-chai'));
    sinon = require('sinon');
    F = require('../src/fnuc');
    delete global.__fnuc;
    F.expose(global);
  }

  assert = sinon.assert, spy = sinon.spy, mock = sinon.mock, stub = sinon.stub, sandbox = sinon.sandbox;

  date = new Date(1421584085148);

  Foo = (function() {
    function Foo() {}

    return Foo;

  })();

  TYPES = [
    {
      v: void 0,
      t: 'undefined',
      d: '',
      truthy: false,
      func: false
    }, {
      v: null,
      t: 'null',
      d: '',
      truthy: false,
      func: false
    }, {
      v: false,
      t: 'boolean',
      d: '',
      truthy: false,
      func: false
    }, {
      v: true,
      t: 'boolean',
      d: '',
      truthy: true,
      func: false
    }, {
      v: '',
      t: 'string',
      d: '[empty]',
      truthy: false,
      func: String
    }, {
      v: 'str',
      t: 'string',
      d: '',
      truthy: true,
      func: String
    }, {
      v: 0,
      t: 'number',
      d: '[0]',
      truthy: false,
      func: Number
    }, {
      v: 42,
      t: 'number',
      d: '',
      truthy: true,
      func: Number
    }, {
      v: [],
      t: 'array',
      d: '[empty]',
      truthy: true,
      func: Array
    }, {
      v: [0, 1, {}],
      t: 'array',
      d: '',
      truthy: true,
      func: Array
    }, {
      v: date,
      t: 'date',
      d: '',
      truthy: true,
      func: Date
    }, {
      v: {},
      t: 'object',
      d: '[empty]',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: {
        a: 1,
        b: {}
      },
      t: 'object',
      d: '',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: new Foo,
      t: 'object',
      d: '[proto]',
      truthy: true,
      func: Object
    }, {
      v: {
        a: [
          {
            b: 1
          }
        ]
      },
      t: 'object',
      d: '',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: {
        a: [{}]
      },
      t: 'object',
      d: '',
      truthy: true,
      func: Object,
      plain: true
    }
  ];

  TYPE_PROTO = TYPES.filter(function(spec) {
    return spec.t === 'object' && !spec.plain;
  });

  TYPE_NO_PROTO = TYPES.filter(function(spec) {
    return spec.t !== 'object' || spec.plain;
  });

  TYPE_ARR = TYPES.filter(function(spec) {
    return spec.t === 'array';
  });

  TYPE_PLAIN = TYPES.filter(function(spec) {
    return spec.t === 'object' && spec.plain;
  });

  describe('type', function() {
    return describe('for 1 arg', function() {
      return TYPES.forEach(function(spec) {
        return it("works for " + spec.t + spec.d, function() {
          return type(spec.v).should.eql(spec.t);
        });
      });
    });
  });

  describe('typeis', function() {
    describe('works on the form (a,s)', function() {
      return TYPES.forEach(function(spec) {
        return it("for type " + spec.t + spec.d, function() {
          return typeis(spec.v, spec.t).should.be["true"];
        });
      });
    });
    return describe('works curried (s)(a)', function() {
      return TYPES.forEach(function(spec) {
        return it("for type " + spec.t + spec.d, function() {
          return typeis(spec.t)(spec.v).should.be["true"];
        });
      });
    });
  });

  describe('isplain', function() {
    return describe('tells whether something is a plain object', function() {
      return TYPES.forEach(function(spec) {
        return it("for type " + spec.t + spec.d, function() {
          return isplain(spec.v).should.eql(!!spec.plain);
        });
      });
    });
  });

  describe('merge', function() {
    return describe('alters first argument with consecutive and', function() {
      it('handles no object', function() {
        return expect(merge()).to.be.undefined;
      });
      it('handles one object', function() {
        return merge({
          a: 1
        }).should.eql({
          a: 1
        });
      });
      it('handles two objects', function() {
        return merge({
          a: 1
        }, {
          b: 2
        }).should.eql({
          a: 1,
          b: 2
        });
      });
      it('handles three objects', function() {
        return merge({
          a: 1
        }, {
          b: 2
        }, {
          c: 3
        }).should.eql({
          a: 1,
          b: 2,
          c: 3
        });
      });
      it('overwrites existing keys', function() {
        return merge({
          a: 1
        }, {
          a: 2
        }).should.eql({
          a: 2
        });
      });
      it('overwrites with precedence', function() {
        return merge({
          a: 1
        }, {
          a: 2
        }, {
          a: 3
        }).should.eql({
          a: 3
        });
      });
      it('ignores undefined values', function() {
        return merge({
          a: 1
        }, {
          a: void 0
        }).should.eql({
          a: 1
        });
      });
      return it('leaves undefined in first be', function() {
        return merge({
          a: void 0
        }, {
          b: 2
        }).should.eql({
          a: void 0,
          b: 2
        });
      });
    });
  });

  describe('mixin', function() {
    return describe('returns a new object with all arguments merged and', function() {
      it('handles no object', function() {
        return expect(mixin()).to.eql({});
      });
      it('handles one object', function() {
        var a, r;
        (r = mixin(a = {
          a: 1
        })).should.eql({
          a: 1
        });
        return a.should.not.equal(r);
      });
      it('handles two objects', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          b: 2
        }).should.eql({
          a: 1,
          b: 2
        });
        return a.should.eql({
          a: 1
        });
      });
      it('handles three objects', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          b: 2
        }, {
          c: 3
        }).should.eql({
          a: 1,
          b: 2,
          c: 3
        });
        return a.should.eql({
          a: 1
        });
      });
      it('overwrites existing keys', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          a: 2
        }).should.eql({
          a: 2
        });
        return a.should.eql({
          a: 1
        });
      });
      it('overwrites with precedence', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          a: 2
        }, {
          a: 3
        }).should.eql({
          a: 3
        });
        return a.should.eql({
          a: 1
        });
      });
      it('ignores undefined values', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          a: void 0
        }).should.eql({
          a: 1
        });
        return a.should.eql({
          a: 1
        });
      });
      return it('leaves undefined in first be', function() {
        var a;
        mixin(a = {
          a: void 0
        }, {
          b: 2
        }).should.eql({
          b: 2
        });
        return a.should.eql({
          a: void 0
        });
      });
    });
  });

  describe('shallow', function() {
    describe('does a shallow copy', function() {
      return TYPE_NO_PROTO.forEach(function(spec) {
        return it("for built in type " + spec.t + spec.d, function() {
          var r;
          r = shallow(spec.v);
          return expect(r).to.eql(spec.v);
        });
      });
    });
    describe('wont handle proto', function() {
      return TYPE_PROTO.forEach(function(spec) {
        return it('throws an exception', function() {
          return expect(function() {
            return shallow(spec.v);
          }).to["throw"]('Can\'t shallow [object Object]');
        });
      });
    });
    return describe('specifically', function() {
      describe('for arrays', function() {
        return TYPE_ARR.forEach(function(spec) {
          return it("copies nested by reference for " + spec.t + spec.d, function() {
            var a, i, r, _i, _len;
            r = shallow(spec.v);
            r.should.not.equal(spec.v);
            for (i = _i = 0, _len = r.length; _i < _len; i = ++_i) {
              a = r[i];
              r[i].should.equal(spec.v[i]);
            }
            return r.length.should.eql(spec.v.length);
          });
        });
      });
      return describe('for objects', function() {
        return TYPE_PLAIN.forEach(function(spec) {
          return it("copies nested by reference for " + spec.t + spec.d, function() {
            var k, r, v;
            r = shallow(spec.v);
            r.should.not.equal(spec.v);
            for (k in r) {
              v = r[k];
              v.should.equal(spec.v[k]);
            }
            return Object.keys(r).length.should.eql(Object.keys(spec.v).length);
          });
        });
      });
    });
  });

  describe('clone', function() {
    describe('does a deep copy', function() {
      return TYPE_NO_PROTO.forEach(function(spec) {
        return it("for built in type " + spec.t + spec.d, function() {
          var r;
          r = clone(spec.v);
          return expect(r).to.eql(spec.v);
        });
      });
    });
    describe('wont handle proto', function() {
      return TYPE_PROTO.forEach(function(spec) {
        return it('throws an exception', function() {
          return expect(function() {
            return clone(spec.v);
          }).to["throw"]('Can\'t shallow [object Object]');
        });
      });
    });
    return describe('specifically', function() {
      describe('for arrays', function() {
        return TYPE_ARR.forEach(function(spec) {
          return it("clones nested for " + spec.t + spec.d, function() {
            var a, i, r, _i, _len;
            r = clone(spec.v);
            r.should.not.equal(spec.v);
            for (i = _i = 0, _len = r.length; _i < _len; i = ++_i) {
              a = r[i];
              if (typeis(a, 'number')) {
                r[i].should.equal(spec.v[i]);
              } else {
                r[i].should.not.equal(spec.v[i]);
              }
            }
            return r.length.should.eql(spec.v.length);
          });
        });
      });
      return describe('for objects', function() {
        return TYPE_PLAIN.forEach(function(spec) {
          return it("clones nested for " + spec.t + spec.d, function() {
            var k, r, v;
            r = clone(spec.v);
            r.should.not.equal(spec.v);
            for (k in r) {
              v = r[k];
              if (typeis(v, 'number')) {
                v.should.equal(spec.v[k]);
              } else {
                v.should.not.equal(spec.v[k]);
              }
            }
            return Object.keys(r).length.should.eql(Object.keys(spec.v).length);
          });
        });
      });
    });
  });

  describe('arity', function() {
    it('returns the arity of (f)', function() {
      arity(function() {}).should.eql(0);
      arity(function(a) {}).should.eql(1);
      return arity(function(a, b) {}).should.eql(2);
    });
    it('chops the arity to the given number if (f,n)', function() {
      var n, _i, _results;
      _results = [];
      for (n = _i = 0; _i <= 10; n = ++_i) {
        _results.push(arity(arity((function(a, b, c) {}), n)).should.eql(n));
      }
      return _results;
    });
    it('has a curried variant for (n)', function() {
      var n, _i, _results;
      _results = [];
      for (n = _i = 0; _i <= 10; n = ++_i) {
        _results.push(arity(arity(n)(function(a, b, c) {})).should.eql(n));
      }
      return _results;
    });
    describe('unary', function() {
      return it('is arity(1)', function() {
        var f;
        f = unary((function(a, b, c, d, e) {}));
        return f.length.should.eql(1);
      });
    });
    describe('binary', function() {
      return it('is arity(2)', function() {
        var f;
        f = binary(function(a, b, c, d, e) {});
        return f.length.should.eql(2);
      });
    });
    return describe('ternary', function() {
      return it('is arity(3)', function() {
        var f;
        f = ternary(function(a, b, c, d, e) {});
        return f.length.should.eql(3);
      });
    });
  });

  describe('partial', function() {
    return describe('partially fills in arguments from the left', function() {
      it('executes arity(0)', function() {
        var r;
        r = partial((function() {
          return 42;
        }));
        return r.should.eql(42);
      });
      it('executes arity(0) with arguments', function() {
        var r;
        r = partial((function() {
          return 42;
        }), 1, 2, 3);
        return r.should.eql(42);
      });
      it('handles arity(1)', function() {
        var r;
        r = partial((function(a) {
          return a + 42;
        }));
        r.should.be.a["function"];
        return r(1, 2, 3).should.eql(43);
      });
      it('executes arity(1) with arguments', function() {
        var r;
        r = partial((function(a) {
          return a + 42;
        }), 1, 2);
        r.should.not.be.a["function"];
        return r.should.eql(43);
      });
      it('works for arity(2)', function() {
        var r;
        r = partial((function(a, b) {
          return a / b;
        }), 42);
        r.should.be.a["function"];
        arity(r).should.eql(1);
        return r(2, 3, 4).should.eql(21);
      });
      it('executes arity(2) with arguments', function() {
        var r;
        r = partial((function(a, b) {
          return a / b;
        }), 42, 2);
        r.should.not.be.a["function"];
        return r.should.eql(21);
      });
      it('works for arity(3) with one arg', function() {
        var r;
        r = partial((function(a, b, c) {
          return a / (b / c);
        }), 12);
        r.should.be.a["function"];
        arity(r).should.eql(2);
        return r(3, 2, 5).should.eql(8);
      });
      it('works for arity(3) with two arg', function() {
        var r;
        r = partial((function(a, b, c) {
          return a / (b / c);
        }), 12, 3);
        r.should.be.a["function"];
        arity(r).should.eql(1);
        return r(2, 5).should.eql(8);
      });
      return it('executes arity(3) with arguments', function() {
        var r;
        r = partial((function(a, b, c) {
          return a / (b / c);
        }), 12, 3, 2, 5);
        r.should.not.be.a["function"];
        return r.should.eql(8);
      });
    });
  });

  describe('partialr', function() {
    return describe('partially fills in arguments from the right', function() {
      it('executes arity(0)', function() {
        var r;
        r = partialr((function() {
          return 42;
        }));
        return r.should.eql(42);
      });
      it('executes arity(0) with arguments', function() {
        var r;
        r = partialr((function() {
          return 42;
        }), 1, 2, 3);
        return r.should.eql(42);
      });
      it('handles arity(1)', function() {
        var r;
        r = partialr((function(a) {
          return a + 42;
        }));
        r.should.be.a["function"];
        return r(1, 2, 3).should.eql(43);
      });
      it('executes arity(1) with arguments', function() {
        var r;
        r = partialr((function(a) {
          return a + 42;
        }), 1, 2);
        r.should.not.be.a["function"];
        return r.should.eql(43);
      });
      it('works for arity(2)', function() {
        var r;
        r = partialr((function(a, b) {
          return a / b;
        }), 2);
        r.should.be.a["function"];
        arity(r).should.eql(1);
        return r(42, 3, 4).should.eql(21);
      });
      it('executes arity(2) with arguments', function() {
        var r;
        r = partialr((function(a, b) {
          return a / b;
        }), 42, 2);
        r.should.not.be.a["function"];
        return r.should.eql(21);
      });
      it('works for arity(3) with one arg', function() {
        var r;
        r = partialr((function(a, b, c) {
          return a / (b / c);
        }), 2);
        r.should.be.a["function"];
        arity(r).should.eql(2);
        return r(12, 3, 5).should.eql(8);
      });
      it('works for arity(3) with two arg', function() {
        var r;
        r = partialr((function(a, b, c) {
          return a / (b / c);
        }), 3, 2);
        r.should.be.a["function"];
        arity(r).should.eql(1);
        return r(12, 5).should.eql(8);
      });
      return it('executes arity(3) with arguments', function() {
        var r;
        r = partialr((function(a, b, c) {
          return a / (b / c);
        }), 12, 3, 2, 5);
        r.should.not.be.a["function"];
        return r.should.eql(8);
      });
    });
  });

  describe('curry', function() {
    it('does nothing for arity(f) == 0', function() {
      var f, g;
      f = function() {};
      g = curry(f);
      return g.should.equal(f);
    });
    it('does nothing for arity(f) == 1', function() {
      var f, g;
      f = function(n) {};
      g = curry(f);
      return g.should.equal(f);
    });
    describe('(a,b) ->', function() {
      var div;
      div = curry(function(a, b) {
        return a / b;
      });
      it('turns to (b) -> (a) ->', function() {
        var div2;
        div2 = div(2);
        return div2(10).should.eql(5);
      });
      it('maintains arity for curried func', function() {
        return arity(div).should.eql(2);
      });
      it('returns a smaller arity func after partial apply', function() {
        var div2;
        div2 = div(2);
        return arity(div2).should.eql(1);
      });
      return it('can still apply (a,b) to curried (a,b) ->', function() {
        return div(10, 2).should.eql(5);
      });
    });
    return describe('(a,b,c) ->', function() {
      var divt;
      divt = curry(function(a, b, c) {
        return a / (b / c);
      });
      it('turns to (c) -> (b) -> (a) ->', function() {
        var div2, div4;
        div2 = divt(2);
        div4 = div2(8);
        return div4(80).should.eql(20);
      });
      it('maintains arity for curried func', function() {
        return arity(divt).should.eql(3);
      });
      it('returns a small arity func after partial apply', function() {
        var div2, div4;
        div2 = divt(2);
        div4 = div2(8);
        arity(div2).should.eql(2);
        return arity(div4).should.eql(1);
      });
      it('can be partially applied with (b,c)', function() {
        var div4;
        div4 = divt(8, 2);
        return div4(80).should.equal(20);
      });
      it('does correct arity for partial applied', function() {
        var div4;
        div4 = divt(8, 2);
        return arity(div4).should.eql(1);
      });
      it('can still apply (a,b,c) to curried (a,b,c) ->', function() {
        return divt(80, 8, 2).should.eql(20);
      });
      it('can apply (b,c) to partial applied curried (a,b,c) ->', function() {
        var div2;
        div2 = divt(2);
        return div2(80, 8).should.eql(20);
      });
      return it('doesnt splice in more arguments for a partially applied', function() {
        var div2;
        div2 = divt(2);
        return div2(100, 25, 4).should.eql(8);
      });
    });
  });

  describe('flip', function() {
    describe('(a,b) ->', function() {
      var f, f1;
      f = flip((f1 = function(a, b) {
        return a / b;
      }));
      it('flips the arguments to (b,a) ->', function() {
        return f(2, 10).should.eql(5);
      });
      it('keeps arity', function() {
        return arity(f).should.eql(2);
      });
      it('is commutative', function() {
        return flip(f).should.equal(f1);
      });
      it('flips curried functions', function() {
        f = flip(curry(function(a, b) {
          return a / b;
        }));
        f(2, 10).should.equal(5);
        return f(10)(2).should.equal(5);
      });
      it('is commutative for curried functions', function() {
        f = flip((f1 = curry(function(a, b) {
          return a / b;
        })));
        return flip(f).should.equal(f1);
      });
      it('flips partially applied curried functions', function() {
        f = flip((curry(function(a, b) {
          return a / b;
        }))(2));
        return f(8).should.eql(4);
      });
      return it('is commutative for partially applied curried functions', function() {
        f = flip((f1 = (curry(function(a, b) {
          return a / b;
        }))(2)));
        return flip(f).should.equal(f1);
      });
    });
    return describe('(a,b,c) ->', function() {
      var f, f1;
      f = flip((f1 = function(a, b, c) {
        return a / (b / c);
      }));
      it('flips the arguments to (c,b,a) ->', function() {
        return f(2, 3, 12).should.eql(8);
      });
      it('keeps arity', function() {
        return arity(f).should.eql(3);
      });
      it('is commutative', function() {
        return flip(f).should.equal(f1);
      });
      it('flips curried functions', function() {
        f = flip(curry(function(a, b, c) {
          return a / (b / c);
        }));
        f(2, 3, 12).should.equal(8);
        return f(12)(3)(2).should.equal(8);
      });
      it('is commutative for curried functions', function() {
        f = flip((f1 = curry(function(a, b, c) {
          return a / (b / c);
        })));
        return flip(f).should.equal(f1);
      });
      it('flips partially applied curried functions', function() {
        f = flip((curry(function(a, b, c) {
          return a / (b / c);
        }))(2));
        f(3, 12).should.eql(8);
        return f(12)(3).should.eql(8);
      });
      return it('is commutative partially applied curried functions', function() {
        f = flip((f1 = (curry(function(a, b, c) {
          return a / (b / c);
        }))(2)));
        return flip(f).should.equal(f1);
      });
    });
  });

  describe('compose', function() {
    describe('(f2,f1)', function() {
      var f, f1, f2;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f = compose(f2, f1);
      it('is turned to f2(f1)', function() {
        return f(6, 4).should.eql(5);
      });
      return it('maintains arity for f1', function() {
        return arity(f).should.eql(2);
      });
    });
    return describe('(f3,f2,f1)', function() {
      var f, f1, f2, f3;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f3 = function(d) {
        return d / 3;
      };
      f = compose(f3, f2, f1);
      it('is turned to f3(f2(f1))', function() {
        return f(7, 5).should.eql(2);
      });
      return it('maintains arity for f1', function() {
        return arity(f).should.eql(2);
      });
    });
  });

  describe('sequence', function() {
    describe('(f1,f2)', function() {
      var f, f1, f2;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f = sequence(f1, f2);
      it('is turned to f2(f1)', function() {
        return f(6, 4).should.eql(5);
      });
      return it('maintains arity for f1', function() {
        return arity(f).should.eql(2);
      });
    });
    return describe('(f1,f2,f3)', function() {
      var f, f1, f2, f3;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f3 = function(d) {
        return d / 3;
      };
      f = sequence(f1, f2, f3);
      it('is turned to f3(f2(f1))', function() {
        return f(7, 5).should.eql(2);
      });
      return it('maintains arity for f1', function() {
        return arity(f).should.eql(2);
      });
    });
  });

  describe('I/ident', function() {
    it('returns the arg in', function() {
      return I(42).should.eql(42);
    });
    it('is of arity 1', function() {
      return arity(I).should.eql(1);
    });
    return it('ignores additional args', function() {
      return I(42, 2).should.eql(42);
    });
  });

  describe('tap', function() {
    var f;
    f = spy(I);
    it('is the mother of all side effect funcs', function() {
      tap(42, f).should.eql(42);
      return f.should.have.been.calledWith(42);
    });
    it('is curried', function() {
      return tap(f)(42).should.eql(42);
    });
    return it('has arity 2', function() {
      return tap.length.should.eql(2);
    });
  });

  foldfn = function(p, c) {
    return p + c / p;
  };

  FN_TEST = [
    {
      n: 'head',
      s: '[] -> undef',
      f: head,
      ar: 1,
      as: [[]],
      eq: void 0
    }, {
      n: 'head',
      s: '[a] -> a',
      f: head,
      ar: 1,
      as: [[1, 2, 3]],
      eq: 1
    }, {
      n: 'tail',
      s: '[] -> []',
      f: tail,
      ar: 1,
      as: [[]],
      eq: []
    }, {
      n: 'tail',
      s: '[a] -> [a]',
      f: tail,
      ar: 1,
      as: [[1, 2, 3]],
      eq: [2, 3]
    }, {
      n: 'last',
      s: '[] -> undef',
      f: last,
      ar: 1,
      as: [[]],
      eq: void 0
    }, {
      n: 'last',
      s: '[a] -> a',
      f: last,
      ar: 1,
      as: [[1, 2, 3]],
      eq: 3
    }, {
      n: 'concat',
      s: 'a, a -> [a]',
      f: concat,
      ar: 0,
      as: [0, 1, 2, 3],
      eq: [0, 1, 2, 3]
    }, {
      n: 'concat',
      s: '[a], a -> [a]',
      f: concat,
      ar: 0,
      as: [[0, 1], 2],
      eq: [0, 1, 2]
    }, {
      n: 'concat',
      s: 'a, [a] -> [a]',
      f: concat,
      ar: 0,
      as: [0, 1, [2, 3]],
      eq: [0, 1, 2, 3]
    }, {
      n: 'concat',
      s: '[a], [a] -> [a]',
      f: concat,
      ar: 0,
      as: [[0, 1], [2, 3]],
      eq: [0, 1, 2, 3]
    }, {
      n: 'each',
      s: '[a], fn -> undef',
      f: each,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a + 1;
        })
      ],
      eq: void 0
    }, {
      n: 'map',
      s: '[a], fn -> [a]',
      f: map,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a + 1;
        })
      ],
      eq: [1, 2, 3]
    }, {
      n: 'filter',
      s: '[a], fn -> [a]',
      f: filter,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a % 2;
        })
      ],
      eq: [1]
    }, {
      n: 'fold',
      s: '[a], fn, v -> *',
      f: fold,
      ar: 3,
      as: [[24, 28], foldfn, 12],
      eq: 16
    }, {
      n: 'fold1',
      s: '[a], fn -> *',
      f: fold1,
      ar: 2,
      as: [[12, 24, 28], foldfn],
      eq: 16
    }, {
      n: 'foldr',
      s: '[a], fn, v -> *',
      f: foldr,
      ar: 3,
      as: [[28, 24], foldfn, 12],
      eq: 16
    }, {
      n: 'foldr1',
      s: '[a], fn -> *',
      f: foldr1,
      ar: 2,
      as: [[28, 24, 12], foldfn],
      eq: 16
    }, {
      n: 'all',
      s: '[a], fn -> b',
      f: all,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a >= 0;
        })
      ],
      eq: true
    }, {
      n: 'any',
      s: '[a], fn -> b',
      f: any,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a > 1;
        })
      ],
      eq: true
    }, {
      n: 'join',
      s: '[a], s -> s',
      f: join,
      ar: 2,
      as: [[0, 1, 2], '-'],
      eq: '0-1-2'
    }, {
      n: 'reverse',
      s: '[a] -> [a]',
      f: reverse,
      ar: 1,
      as: [[0, 1, 2]],
      eq: [2, 1, 0]
    }, {
      n: 'split',
      s: 's, s -> s',
      f: split,
      ar: 2,
      as: ['a#b', '#'],
      eq: ['a', 'b']
    }, {
      n: 'match',
      s: 's, re -> null',
      f: match,
      ar: 2,
      as: ['abc', 'd'],
      eq: null
    }, {
      n: 'match',
      s: 's, s -> [s]',
      f: match,
      ar: 2,
      as: ['abc', 'b'],
      eq: 'abc'.match('b')
    }, {
      n: 'match',
      s: 's, re -> [s]',
      f: match,
      ar: 2,
      as: ['abc', /b/],
      eq: 'abc'.match(/b/)
    }, {
      n: 'replace',
      s: 's, s, s -> s',
      f: replace,
      ar: 3,
      as: ['aba', 'a', 'b'],
      eq: 'bba'
    }, {
      n: 'replace',
      s: 's, re, s -> s',
      f: replace,
      ar: 3,
      as: ['aba', /a/g, 'b'],
      eq: 'bbb'
    }, {
      n: 'search',
      s: 's, s -> b',
      f: search,
      ar: 2,
      as: ['aaaca', 'c'],
      eq: 3
    }, {
      n: 'search',
      s: 's, re -> b',
      f: search,
      ar: 2,
      as: ['aaaca', /ac/],
      eq: 2
    }, {
      n: 'trim',
      s: 's -> s',
      f: trim,
      ar: 1,
      as: ['  abc '],
      eq: 'abc'
    }, {
      n: 'ucase',
      s: 's -> s',
      f: ucase,
      ar: 1,
      as: ['abc'],
      eq: 'ABC'
    }, {
      n: 'lcase',
      s: 's -> s',
      f: lcase,
      ar: 1,
      as: ['ABC'],
      eq: 'abc'
    }, {
      n: 'sort',
      s: '[a], f -> [a]',
      f: sort,
      ar: 2,
      as: [[2, 3, 1], void 0],
      eq: [1, 2, 3]
    }, {
      n: 'sort',
      s: '[a], f -> [a]',
      f: sort,
      ar: 2,
      as: [
        [2, 3, 1], function(a, b) {
          return b - a;
        }
      ],
      eq: [3, 2, 1]
    }, {
      n: 'uniq',
      s: 'null -> null',
      f: uniq,
      ar: 1,
      as: [null],
      eq: null
    }, {
      n: 'uniq',
      s: '[a] -> [a]',
      f: uniq,
      ar: 1,
      as: [[]],
      eq: []
    }, {
      n: 'uniq',
      s: '[a] -> [a]',
      f: uniq,
      ar: 1,
      as: [[1, 2, 2, 1, 2, 3]],
      eq: [1, 2, 3]
    }, {
      n: 'index',
      s: '[a], a -> n',
      f: index,
      ar: 2,
      as: [[1, 2, 3, 4], 3],
      eq: 2
    }, {
      n: 'index',
      s: '[a], a -> n',
      f: index,
      ar: 2,
      as: [[1, 2, 3, 4], 5],
      eq: -1
    }, {
      n: 'contains',
      s: '[a], a -> b',
      f: contains,
      ar: 2,
      as: [[1, 2, 3, 4], 3],
      eq: true
    }, {
      n: 'contains',
      s: '[a], a -> b',
      f: contains,
      ar: 2,
      as: [[1, 2, 3, 4], 5],
      eq: false
    }, {
      n: 'has',
      s: '{k:v}, k -> b',
      f: has,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, 'b'
      ],
      eq: true
    }, {
      n: 'get',
      s: '{k:v}, k -> v',
      f: get,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, 'b'
      ],
      eq: 2
    }, {
      n: 'set',
      s: '{k:v}, k, v -> v',
      f: set,
      ar: 3,
      as: [
        {
          a: 1,
          b: 2
        }, 'b', 3
      ],
      eq: {
        a: 1,
        b: 3
      }
    }, {
      n: 'keys',
      s: '{k:v} -> [k]',
      f: keys,
      ar: 1,
      as: [
        {
          a: 1,
          b: 2
        }
      ],
      eq: ['a', 'b']
    }, {
      n: 'values',
      s: '{k:v} -> [v]',
      f: values,
      ar: 1,
      as: [
        {
          a: 1,
          b: 2
        }
      ],
      eq: [1, 2]
    }, {
      n: 'add',
      s: 'a, a -> a',
      f: add,
      ar: 2,
      as: [12, 2],
      eq: 14
    }, {
      n: 'add',
      s: 'a... -> a',
      f: add,
      ar: 2,
      as: [12, 2, 3],
      eq: 17
    }, {
      n: 'sub',
      s: 'a, a -> a',
      f: sub,
      ar: 2,
      as: [12, 2],
      eq: 10
    }, {
      n: 'sub',
      s: 'a... -> a',
      f: sub,
      ar: 2,
      as: [12, 2, 3],
      eq: 7
    }, {
      n: 'mul',
      s: 'a, a -> a',
      f: mul,
      ar: 2,
      as: [12, 2],
      eq: 24
    }, {
      n: 'mul',
      s: 'a... -> a',
      f: mul,
      ar: 2,
      as: [12, 2, 3],
      eq: 72
    }, {
      n: 'div',
      s: 'a, a -> a',
      f: div,
      ar: 2,
      as: [12, 2],
      eq: 6
    }, {
      n: 'div',
      s: 'a... -> a',
      f: div,
      ar: 2,
      as: [12, 2, 3],
      eq: 2
    }, {
      n: 'mod',
      s: 'a, a -> a',
      f: mod,
      ar: 2,
      as: [17, 6],
      eq: 5
    }, {
      n: 'mod',
      s: 'a... -> a',
      f: mod,
      ar: 2,
      as: [17, 6, 3],
      eq: 2
    }, {
      n: 'min',
      s: 'a, a -> a',
      f: min,
      ar: 2,
      as: [12, 2],
      eq: 2
    }, {
      n: 'min',
      s: 'a... -> a',
      f: min,
      ar: 2,
      as: [12, 3, 2],
      eq: 2
    }, {
      n: 'max',
      s: 'a, a -> a',
      f: max,
      ar: 2,
      as: [12, 2],
      eq: 12
    }, {
      n: 'max',
      s: 'a... -> a',
      f: max,
      ar: 2,
      as: [3, 2, 12],
      eq: 12
    }, {
      n: 'gt',
      s: 'a, a -> a',
      f: gt,
      ar: 2,
      as: [12, 11],
      eq: true
    }, {
      n: 'gt',
      s: 'a, a -> a',
      f: gt,
      ar: 2,
      as: [12, 12],
      eq: false
    }, {
      n: 'gte',
      s: 'a, a -> a',
      f: gte,
      ar: 2,
      as: [12, 12],
      eq: true
    }, {
      n: 'gte',
      s: 'a, a -> a',
      f: gte,
      ar: 2,
      as: [12, 13],
      eq: false
    }, {
      n: 'lt',
      s: 'a, a -> a',
      f: lt,
      ar: 2,
      as: [11, 12],
      eq: true
    }, {
      n: 'lt',
      s: 'a, a -> a',
      f: lt,
      ar: 2,
      as: [12, 12],
      eq: false
    }, {
      n: 'lte',
      s: 'a, a -> a',
      f: lte,
      ar: 2,
      as: [12, 12],
      eq: true
    }, {
      n: 'lte',
      s: 'a, a -> a',
      f: lte,
      ar: 2,
      as: [13, 12],
      eq: false
    }, {
      n: 'eq',
      s: 'a, a -> b',
      f: eq,
      ar: 2,
      as: [0, 0],
      eq: true
    }, {
      n: 'eq',
      s: 'a, a -> b',
      f: eq,
      ar: 2,
      as: [1, 0],
      eq: false
    }, {
      n: 'eq',
      s: 'a, a -> b',
      f: eq,
      ar: 2,
      as: [{}, {}],
      eq: false
    }, {
      n: 'eq',
      s: 'a... -> b',
      f: eq,
      ar: 2,
      as: [1, 1, 2],
      eq: false
    }, {
      n: 'eq',
      s: 'a... -> b',
      f: eq,
      ar: 2,
      as: [false, false, false],
      eq: true
    }, {
      n: 'eq',
      s: 'a... -> b',
      f: eq,
      ar: 2,
      as: [0, 0, 1],
      eq: false
    }, {
      n: 'not',
      s: 'a..., a -> b',
      f: not_,
      ar: 2,
      as: [false, I],
      eq: true
    }, {
      n: 'not',
      s: 'a..., a -> b',
      f: not_,
      ar: 2,
      as: [
        0, 1, function(a, b) {
          return b === 1;
        }
      ],
      eq: false
    }, {
      n: 'pick',
      s: '{k:v}, [k] -> {k:v}',
      f: pick,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, ['b', 'c']
      ],
      eq: {
        b: 2,
        c: 3
      }
    }, {
      n: 'pick',
      s: '{k:v}, k -> {k:v}',
      f: pick,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, 'b', 'c'
      ],
      eq: {
        b: 2,
        c: 3
      }
    }, {
      n: 'pick',
      s: '{k:v}, k -> {k:v}',
      f: pick,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, 'b'
      ],
      eq: {
        b: 2
      }
    }, {
      n: 'evolve',
      s: '{k:v}, {k:(v->v)} -> {k:v}',
      f: evolve,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, {}
      ],
      eq: {
        a: 1,
        b: 2
      }
    }, {
      n: 'evolve',
      s: '{k:v}, {k:(v->v)} -> {k:v}',
      f: evolve,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, {
          a: function(v) {
            return v + 1;
          }
        }
      ],
      eq: {
        a: 2,
        b: 2
      }
    }, {
      n: 'omap',
      s: '{k:v}, ((k,v) -> v) -> {k:v}',
      f: omap,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, function(k, v) {
          if (k === 'b') {
            return v + 40;
          } else {
            return v;
          }
        }
      ],
      eq: {
        a: 1,
        b: 42,
        c: 3
      }
    }, {
      n: 'ofilter',
      s: '{k:v}, ((k,v) -> Boolean) -> {k:v}',
      f: ofilter,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, function(k, v) {
          return k === 'b';
        }
      ],
      eq: {
        b: 2
      }
    }
  ];

  FN_TEST.forEach(function(spec) {
    return describe(spec.n, function() {
      it("has signature " + spec.s, function() {
        return expect(spec.f.apply(spec, spec.as)).to.eql(spec.eq);
      });
      if (spec.ar === spec.as.length) {
        if (spec.ar > 1) {
          it("has a curried variant", function() {
            if (spec.ar === 2) {
              return expect(spec.f(spec.as[1])(spec.as[0])).to.eql(spec.eq);
            } else if (spec.ar === 3) {
              return expect(spec.f(spec.as[2])(spec.as[1])(spec.as[0])).to.eql(spec.eq);
            }
          });
        }
        return it("is of arity(" + spec.ar + ")", function() {
          return spec.f.length.should.eql(spec.ar);
        });
      }
    });
  });

  describe('map', function() {
    var as;
    as = split('abc', '');
    return it('doesnt pass multiple args to map function', function() {
      return map(as, function(v, i, as) {
        expect(i).to.be.undefined;
        expect(as).to.be.undefined;
        return v;
      });
    });
  });

  describe('fold/fold1/foldr/foldr1', function() {
    var as, fs;
    fs = [fold, fold1, foldr, foldr1];
    as = [0, 1, 2, 3];
    return each(fs, function(f) {
      return it('doesnt pass multiple args to fold function', function() {
        return f(as, (function(p, c, i, as) {
          expect(i).to.be.undefined;
          expect(as).to.be.undefined;
          return p + c;
        }), 1);
      });
    });
  });

  describe('and', function() {
    var even, gt10, lt102;
    gt10 = even = lt102 = null;
    beforeEach(function() {
      gt10 = spy(gt(10));
      even = spy(function(n) {
        return n % 2 === 0;
      });
      return lt102 = spy(lt(102));
    });
    it('is of arity(2)', function() {
      return arity(and_).should.eql(2);
    });
    it('wraps two functions f, g and invokes both with &&', function() {
      var f;
      f = and_(gt10, even);
      f(100, 42).should.eql(true);
      gt10.should.have.been.calledOnce;
      gt10.should.have.been.calledWith(100, 42);
      even.should.have.been.calledOnce;
      even.should.have.been.calledWith(100, 42);
      return f(8).should.eql(false);
    });
    it('wraps moar functions f, g, h and invokes both with &&', function() {
      var f;
      f = and_(gt10, even, lt102);
      f(100, 42).should.eql(true);
      gt10.should.have.been.calledOnce;
      gt10.should.have.been.calledWith(100, 42);
      even.should.have.been.calledOnce;
      even.should.have.been.calledWith(100, 42);
      lt102.should.have.been.calledOnce;
      lt102.should.have.been.calledWith(100, 42);
      return f(102).should.eql(false);
    });
    it('is lazy', function() {
      var f, f1, f2;
      f1 = spy(function() {
        return false;
      });
      f2 = spy(function() {
        return true;
      });
      f = and_(f1, f2);
      f().should.eql(false);
      f1.should.have.been.calledOnce;
      return f2.should.not.have.been.calledOnce;
    });
    return it('is aliased', function() {
      return F.and.should.eql(F.and_);
    });
  });

  describe('or', function() {
    var even, gt10, lt102;
    gt10 = even = lt102 = null;
    beforeEach(function() {
      gt10 = spy(gt(10));
      even = spy(function(n) {
        return n % 2 === 0;
      });
      return lt102 = spy(lt(102));
    });
    it('is of arity(2)', function() {
      return arity(or_).should.eql(2);
    });
    it('wraps two functions f, g and invokes both with ||', function() {
      var f;
      f = or_(gt10, even);
      f(8, 42).should.eql(true);
      gt10.should.have.been.calledOnce;
      gt10.should.have.been.calledWith(8, 42);
      even.should.have.been.calledOnce;
      even.should.have.been.calledWith(8, 42);
      return f(9).should.eql(false);
    });
    it('wraps moar functions f, g, h and invokes both with ||', function() {
      var f;
      f = or_(gt10, even, lt102);
      f(9, 42).should.eql(true);
      gt10.should.have.been.calledOnce;
      gt10.should.have.been.calledWith(9, 42);
      even.should.have.been.calledOnce;
      even.should.have.been.calledWith(9, 42);
      lt102.should.have.been.calledOnce;
      return lt102.should.have.been.calledWith(9, 42);
    });
    it('is lazy', function() {
      var f, f1, f2;
      f1 = spy(function() {
        return true;
      });
      f2 = spy(function() {
        return false;
      });
      f = or_(f1, f2);
      f().should.eql(true);
      f1.should.have.been.calledOnce;
      return f2.should.not.have.been.calledOnce;
    });
    return it('is aliased', function() {
      return F.or.should.eql(F.or_);
    });
  });

  describe('not', function() {
    var gt10;
    gt10 = null;
    beforeEach(function() {
      return gt10 = spy(gt(10));
    });
    it('is of arity(2)', function() {
      return arity(not_).should.eql(2);
    });
    it('wraps a function and nots the output', function() {
      var f;
      f = not_(gt10);
      f(12).should.eql(false);
      gt10.should.have.been.calledOnce;
      return gt10.should.have.been.calledWith(12);
    });
    return it('is aliased', function() {
      return F.not.should.eql(F.not_);
    });
  });

  describe('chainable', function() {
    it('makes chainable functions for arity == 1', function() {
      var f, g;
      f = function(a) {
        return a + 14;
      };
      chainable('f', f);
      g = div(2).f;
      return g(100).should.eql(64);
    });
    it('makes chainable functions for arity >= 2', function() {
      var f, g;
      f = function(a, b) {
        if (a === 42) {
          return b;
        } else {
          return 0;
        }
      };
      chainable('guard42', f);
      g = div(2).guard42(17);
      g(100).should.eql(0);
      return g(84).should.eql(17);
    });
    it('wants arity >= 1', function() {
      return expect(function() {
        return chainable('fail', function() {});
      }).to["throw"]('No chainable for arity 0');
    });
    return it('can redefine a chainable', function() {
      var f1, f2, g;
      f1 = function(a) {
        return 0;
      };
      chainable('f', f1);
      f2 = function(b) {
        return 1;
      };
      chainable('f', f2);
      g = add(3).f;
      return g(4).should.eql(1);
    });
  });

  describe('eql', function() {
    return TYPES.forEach(function(v1, i1) {
      return TYPES.forEach(function(v2, i2) {
        var s1, s2;
        s1 = JSON.stringify(v1.v);
        s2 = JSON.stringify(v2.v);
        if (i1 === i2) {
          return it("equals for " + s1 + ", " + s2, function() {
            return eql(v1.v, v2.v).should.eql(true);
          });
        } else {
          return it("not equals for " + s1 + ", " + s2, function() {
            return eql(v1.v, v2.v).should.eql(false);
          });
        }
      });
    });
  });

}).call(this);

//# sourceMappingURL=fnuc-test.js.map
