// Generated by CoffeeScript 1.8.0
(function() {
  var FN_TEST, Foo, TYPES, TYPE_ARR, TYPE_NO_PROTO, TYPE_PLAIN, TYPE_PROTO, assert, chai, date, expect, foldfn, mock, sandbox, sinon, spy, stub;

  if (typeof browsertest !== "undefined" && browsertest !== null) {
    sinon = window.sinon;
    expect = window.chai.expect;
  } else {
    chai = require('chai');
    chai.should();
    expect = chai.expect;
    chai.use(require('sinon-chai'));
    sinon = require('sinon');
    require('../src/fnuc').installTo(global, true);
  }

  assert = sinon.assert, spy = sinon.spy, mock = sinon.mock, stub = sinon.stub, sandbox = sinon.sandbox;

  date = new Date(1421584085148);

  Foo = (function() {
    function Foo() {}

    return Foo;

  })();

  TYPES = [
    {
      v: void 0,
      t: 'undefined',
      d: '',
      truthy: false,
      func: false
    }, {
      v: null,
      t: 'null',
      d: '',
      truthy: false,
      func: false
    }, {
      v: false,
      t: 'boolean',
      d: '',
      truthy: false,
      func: false
    }, {
      v: true,
      t: 'boolean',
      d: '',
      truthy: true,
      func: false
    }, {
      v: '',
      t: 'string',
      d: '[empty]',
      truthy: false,
      func: String
    }, {
      v: 'str',
      t: 'string',
      d: '',
      truthy: true,
      func: String
    }, {
      v: 0,
      t: 'number',
      d: '[0]',
      truthy: false,
      func: Number
    }, {
      v: 42,
      t: 'number',
      d: '',
      truthy: true,
      func: Number
    }, {
      v: [],
      t: 'array',
      d: '[empty]',
      truthy: true,
      func: Array
    }, {
      v: [0, 1, {}],
      t: 'array',
      d: '',
      truthy: true,
      func: Array
    }, {
      v: date,
      t: 'date',
      d: '',
      truthy: true,
      func: Date
    }, {
      v: {},
      t: 'object',
      d: '[empty]',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: {
        a: 1,
        b: {}
      },
      t: 'object',
      d: '',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: new Foo,
      t: 'object',
      d: '[proto]',
      truthy: true,
      func: Object
    }
  ];

  TYPE_PROTO = TYPES.filter(function(spec) {
    return spec.t === 'object' && !spec.plain;
  });

  TYPE_NO_PROTO = TYPES.filter(function(spec) {
    return spec.t !== 'object' || spec.plain;
  });

  TYPE_ARR = TYPES.filter(function(spec) {
    return spec.t === 'array';
  });

  TYPE_PLAIN = TYPES.filter(function(spec) {
    return spec.t === 'object' && spec.plain;
  });

  describe('type', function() {
    describe('for 1 arg', function() {
      return TYPES.forEach(function(spec) {
        return it("works for " + spec.t + spec.d, function() {
          return type(spec.v).should.eql(spec.t);
        });
      });
    });
    return describe('for 2 args', function() {
      describe('can take a string argument', function() {
        return TYPES.forEach(function(spec) {
          return it("for type " + spec.t + spec.d, function() {
            return type(spec.t, spec.v).should.be["true"];
          });
        });
      });
      return describe('can take a Function argument', function() {
        return TYPES.forEach(function(spec) {
          if (spec.func) {
            return it("for type " + spec.t + spec.d, function() {
              return type(spec.func, spec.v).should.be["true"];
            });
          }
        });
      });
    });
  });

  describe('isplain', function() {
    return describe('tells whether something is a plain object', function() {
      return TYPES.forEach(function(spec) {
        return it("for type " + spec.t + spec.d, function() {
          return isplain(spec.v).should.eql(!!spec.plain);
        });
      });
    });
  });

  describe('merge', function() {
    return describe('alters first argument with consecutive and', function() {
      it('handles no object', function() {
        return expect(merge()).to.be.undefined;
      });
      it('handles one object', function() {
        return merge({
          a: 1
        }).should.eql({
          a: 1
        });
      });
      it('handles two objects', function() {
        return merge({
          a: 1
        }, {
          b: 2
        }).should.eql({
          a: 1,
          b: 2
        });
      });
      it('handles three objects', function() {
        return merge({
          a: 1
        }, {
          b: 2
        }, {
          c: 3
        }).should.eql({
          a: 1,
          b: 2,
          c: 3
        });
      });
      it('overwrites existing keys', function() {
        return merge({
          a: 1
        }, {
          a: 2
        }).should.eql({
          a: 2
        });
      });
      it('overwrites with precedence', function() {
        return merge({
          a: 1
        }, {
          a: 2
        }, {
          a: 3
        }).should.eql({
          a: 3
        });
      });
      it('ignores undefined values', function() {
        return merge({
          a: 1
        }, {
          a: void 0
        }).should.eql({
          a: 1
        });
      });
      return it('leaves undefined in first be', function() {
        return merge({
          a: void 0
        }, {
          b: 2
        }).should.eql({
          a: void 0,
          b: 2
        });
      });
    });
  });

  describe('mixin', function() {
    return describe('returns a new object with all arguments merged and', function() {
      it('handles no object', function() {
        return expect(mixin()).to.eql({});
      });
      it('handles one object', function() {
        var a, r;
        (r = mixin(a = {
          a: 1
        })).should.eql({
          a: 1
        });
        return a.should.not.equal(r);
      });
      it('handles two objects', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          b: 2
        }).should.eql({
          a: 1,
          b: 2
        });
        return a.should.eql({
          a: 1
        });
      });
      it('handles three objects', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          b: 2
        }, {
          c: 3
        }).should.eql({
          a: 1,
          b: 2,
          c: 3
        });
        return a.should.eql({
          a: 1
        });
      });
      it('overwrites existing keys', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          a: 2
        }).should.eql({
          a: 2
        });
        return a.should.eql({
          a: 1
        });
      });
      it('overwrites with precedence', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          a: 2
        }, {
          a: 3
        }).should.eql({
          a: 3
        });
        return a.should.eql({
          a: 1
        });
      });
      it('ignores undefined values', function() {
        var a;
        mixin(a = {
          a: 1
        }, {
          a: void 0
        }).should.eql({
          a: 1
        });
        return a.should.eql({
          a: 1
        });
      });
      return it('leaves undefined in first be', function() {
        var a;
        mixin(a = {
          a: void 0
        }, {
          b: 2
        }).should.eql({
          b: 2
        });
        return a.should.eql({
          a: void 0
        });
      });
    });
  });

  describe('shallow', function() {
    describe('does a shallow copy', function() {
      return TYPE_NO_PROTO.forEach(function(spec) {
        return it("for built in type " + spec.t + spec.d, function() {
          var r;
          r = shallow(spec.v);
          return expect(r).to.eql(spec.v);
        });
      });
    });
    describe('wont handle proto', function() {
      return TYPE_PROTO.forEach(function(spec) {
        return it('throws an exception', function() {
          return expect(function() {
            return shallow(spec.v);
          }).to["throw"]('Can\'t shallow [object Object]');
        });
      });
    });
    return describe('specifically', function() {
      describe('for arrays', function() {
        return TYPE_ARR.forEach(function(spec) {
          return it("copies nested by reference for " + spec.t + spec.d, function() {
            var a, i, r, _i, _len;
            r = shallow(spec.v);
            r.should.not.equal(spec.v);
            for (i = _i = 0, _len = r.length; _i < _len; i = ++_i) {
              a = r[i];
              r[i].should.equal(spec.v[i]);
            }
            return r.length.should.eql(spec.v.length);
          });
        });
      });
      return describe('for objects', function() {
        return TYPE_PLAIN.forEach(function(spec) {
          return it("copies nested by reference for " + spec.t + spec.d, function() {
            var k, r, v;
            r = shallow(spec.v);
            r.should.not.equal(spec.v);
            for (k in r) {
              v = r[k];
              v.should.equal(spec.v[k]);
            }
            return Object.keys(r).length.should.eql(Object.keys(spec.v).length);
          });
        });
      });
    });
  });

  describe('clone', function() {
    describe('does a deep copy', function() {
      return TYPE_NO_PROTO.forEach(function(spec) {
        return it("for built in type " + spec.t + spec.d, function() {
          var r;
          r = clone(spec.v);
          return expect(r).to.eql(spec.v);
        });
      });
    });
    describe('wont handle proto', function() {
      return TYPE_PROTO.forEach(function(spec) {
        return it('throws an exception', function() {
          return expect(function() {
            return clone(spec.v);
          }).to["throw"]('Can\'t shallow [object Object]');
        });
      });
    });
    return describe('specifically', function() {
      describe('for arrays', function() {
        return TYPE_ARR.forEach(function(spec) {
          return it("clones nested for " + spec.t + spec.d, function() {
            var a, i, r, _i, _len;
            r = clone(spec.v);
            r.should.not.equal(spec.v);
            for (i = _i = 0, _len = r.length; _i < _len; i = ++_i) {
              a = r[i];
              if (type('number', a)) {
                r[i].should.equal(spec.v[i]);
              } else {
                r[i].should.not.equal(spec.v[i]);
              }
            }
            return r.length.should.eql(spec.v.length);
          });
        });
      });
      return describe('for objects', function() {
        return TYPE_PLAIN.forEach(function(spec) {
          return it("clones nested for " + spec.t + spec.d, function() {
            var k, r, v;
            r = clone(spec.v);
            r.should.not.equal(spec.v);
            for (k in r) {
              v = r[k];
              if (type('number', v)) {
                v.should.equal(spec.v[k]);
              } else {
                v.should.not.equal(spec.v[k]);
              }
            }
            return Object.keys(r).length.should.eql(Object.keys(spec.v).length);
          });
        });
      });
    });
  });

  describe('arity', function() {
    it('returns the arity of (f)', function() {
      arity(function() {}).should.eql(0);
      arity(function(a) {}).should.eql(1);
      return arity(function(a, b) {}).should.eql(2);
    });
    it('chops the arity to the given number if (f,n)', function() {
      var n, _i, _results;
      _results = [];
      for (n = _i = 0; _i <= 10; n = ++_i) {
        _results.push(arity(arity((function(a, b, c) {}), n)).should.eql(n));
      }
      return _results;
    });
    it('has a curried variant for (n)', function() {
      var n, _i, _results;
      _results = [];
      for (n = _i = 0; _i <= 10; n = ++_i) {
        _results.push(arity(arity(n)(function(a, b, c) {})).should.eql(n));
      }
      return _results;
    });
    describe('unary', function() {
      return it('is arity(1)', function() {
        var f;
        f = unary((function(a, b, c, d, e) {}));
        return f.length.should.eql(1);
      });
    });
    describe('binary', function() {
      return it('is arity(2)', function() {
        var f;
        f = binary(function(a, b, c, d, e) {});
        return f.length.should.eql(2);
      });
    });
    return describe('ternary', function() {
      return it('is arity(3)', function() {
        var f;
        f = ternary(function(a, b, c, d, e) {});
        return f.length.should.eql(3);
      });
    });
  });

  describe('lpartial', function() {
    return describe('partially fills in arguments from the left', function() {
      it('executes arity(0)', function() {
        var r;
        r = lpartial((function() {
          return 42;
        }));
        return r.should.eql(42);
      });
      it('executes arity(0) with arguments', function() {
        var r;
        r = lpartial((function() {
          return 42;
        }), 1, 2, 3);
        return r.should.eql(42);
      });
      it('handles arity(1)', function() {
        var r;
        r = lpartial((function(a) {
          return a + 42;
        }));
        r.should.be.a["function"];
        return r(1, 2, 3).should.eql(43);
      });
      it('executes arity(1) with arguments', function() {
        var r;
        r = lpartial((function(a) {
          return a + 42;
        }), 1, 2);
        r.should.not.be.a["function"];
        return r.should.eql(43);
      });
      it('works for arity(2)', function() {
        var r;
        r = lpartial((function(a, b) {
          return a / b;
        }), 42);
        r.should.be.a["function"];
        arity(r).should.eql(1);
        return r(2, 3, 4).should.eql(21);
      });
      it('executes arity(2) with arguments', function() {
        var r;
        r = lpartial((function(a, b) {
          return a / b;
        }), 42, 2);
        r.should.not.be.a["function"];
        return r.should.eql(21);
      });
      it('works for arity(3) with one arg', function() {
        var r;
        r = lpartial((function(a, b, c) {
          return a / (b / c);
        }), 12);
        r.should.be.a["function"];
        arity(r).should.eql(2);
        return r(3, 2, 5).should.eql(8);
      });
      it('works for arity(3) with two arg', function() {
        var r;
        r = lpartial((function(a, b, c) {
          return a / (b / c);
        }), 12, 3);
        r.should.be.a["function"];
        arity(r).should.eql(1);
        return r(2, 5).should.eql(8);
      });
      return it('executes arity(3) with arguments', function() {
        var r;
        r = lpartial((function(a, b, c) {
          return a / (b / c);
        }), 12, 3, 2, 5);
        r.should.not.be.a["function"];
        return r.should.eql(8);
      });
    });
  });

  describe('rpartial', function() {
    return describe('partially fills in arguments from the right', function() {
      it('executes arity(0)', function() {
        var r;
        r = rpartial((function() {
          return 42;
        }));
        return r.should.eql(42);
      });
      it('executes arity(0) with arguments', function() {
        var r;
        r = rpartial((function() {
          return 42;
        }), 1, 2, 3);
        return r.should.eql(42);
      });
      it('handles arity(1)', function() {
        var r;
        r = rpartial((function(a) {
          return a + 42;
        }));
        r.should.be.a["function"];
        return r(1, 2, 3).should.eql(43);
      });
      it('executes arity(1) with arguments', function() {
        var r;
        r = rpartial((function(a) {
          return a + 42;
        }), 1, 2);
        r.should.not.be.a["function"];
        return r.should.eql(43);
      });
      it('works for arity(2)', function() {
        var r;
        r = rpartial((function(a, b) {
          return a / b;
        }), 2);
        r.should.be.a["function"];
        arity(r).should.eql(1);
        return r(42, 3, 4).should.eql(21);
      });
      it('executes arity(2) with arguments', function() {
        var r;
        r = rpartial((function(a, b) {
          return a / b;
        }), 42, 2);
        r.should.not.be.a["function"];
        return r.should.eql(21);
      });
      it('works for arity(3) with one arg', function() {
        var r;
        r = rpartial((function(a, b, c) {
          return a / (b / c);
        }), 2);
        r.should.be.a["function"];
        arity(r).should.eql(2);
        return r(12, 3, 5).should.eql(8);
      });
      it('works for arity(3) with two arg', function() {
        var r;
        r = rpartial((function(a, b, c) {
          return a / (b / c);
        }), 3, 2);
        r.should.be.a["function"];
        arity(r).should.eql(1);
        return r(12, 5).should.eql(8);
      });
      return it('executes arity(3) with arguments', function() {
        var r;
        r = rpartial((function(a, b, c) {
          return a / (b / c);
        }), 12, 3, 2, 5);
        r.should.not.be.a["function"];
        return r.should.eql(8);
      });
    });
  });

  describe('curry', function() {
    describe('(a,b) ->', function() {
      var div;
      div = curry(function(a, b) {
        return a / b;
      });
      it('turns to (b) -> (a) ->', function() {
        var div2;
        div2 = div(2);
        return div2(10).should.eql(5);
      });
      it('maintains arity for curried func', function() {
        return arity(div).should.eql(2);
      });
      it('returns a smaller arity func after partial apply', function() {
        var div2;
        div2 = div(2);
        return arity(div2).should.eql(1);
      });
      return it('can still apply (a,b) to curried (a,b) ->', function() {
        return div(10, 2).should.eql(5);
      });
    });
    return describe('(a,b,c) ->', function() {
      var divt;
      divt = curry(function(a, b, c) {
        return a / (b / c);
      });
      it('turns to (c) -> (b) -> (a) ->', function() {
        var div2, div4;
        div2 = divt(2);
        div4 = div2(8);
        return div4(80).should.eql(20);
      });
      it('maintains arity for curried func', function() {
        return arity(divt).should.eql(3);
      });
      it('returns a small arity func after partial apply', function() {
        var div2, div4;
        div2 = divt(2);
        div4 = div2(8);
        arity(div2).should.eql(2);
        return arity(div4).should.eql(1);
      });
      it('can be partially applied with (b,c)', function() {
        var div4;
        div4 = divt(8, 2);
        return div4(80).should.equal(20);
      });
      it('does correct arity for partial applied', function() {
        var div4;
        div4 = divt(8, 2);
        return arity(div4).should.eql(1);
      });
      it('can still apply (a,b,c) to curried (a,b,c) ->', function() {
        return divt(80, 8, 2).should.eql(20);
      });
      return it('can apply (b,c) to partial applied curried (a,b,c) ->', function() {
        var div2;
        div2 = divt(2);
        return div2(80, 8).should.eql(20);
      });
    });
  });

  describe('flip', function() {
    describe('(a,b) ->', function() {
      var f, f1;
      f = flip((f1 = function(a, b) {
        return a / b;
      }));
      it('flips the arguments to (b,a) ->', function() {
        return f(2, 10).should.eql(5);
      });
      it('keeps arity', function() {
        return arity(f).should.eql(2);
      });
      it('is commutative', function() {
        return flip(f).should.equal(f1);
      });
      it('flips curried functions', function() {
        f = flip(curry(function(a, b) {
          return a / b;
        }));
        f(2, 10).should.equal(5);
        return f(10)(2).should.equal(5);
      });
      it('is commutative for curried functions', function() {
        f = flip((f1 = curry(function(a, b) {
          return a / b;
        })));
        return flip(f).should.equal(f1);
      });
      it('flips partially applied curried functions', function() {
        f = flip((curry(function(a, b) {
          return a / b;
        }))(2));
        return f(8).should.eql(4);
      });
      return it('is commutative for partially applied curried functions', function() {
        f = flip((f1 = (curry(function(a, b) {
          return a / b;
        }))(2)));
        return flip(f).should.equal(f1);
      });
    });
    return describe('(a,b,c) ->', function() {
      var f, f1;
      f = flip((f1 = function(a, b, c) {
        return a / (b / c);
      }));
      it('flips the arguments to (c,b,a) ->', function() {
        return f(2, 3, 12).should.eql(8);
      });
      it('keeps arity', function() {
        return arity(f).should.eql(3);
      });
      it('is commutative', function() {
        return flip(f).should.equal(f1);
      });
      it('flips curried functions', function() {
        f = flip(curry(function(a, b, c) {
          return a / (b / c);
        }));
        f(2, 3, 12).should.equal(8);
        return f(12)(3)(2).should.equal(8);
      });
      it('is commutative for curried functions', function() {
        f = flip((f1 = curry(function(a, b, c) {
          return a / (b / c);
        })));
        return flip(f).should.equal(f1);
      });
      it('flips partially applied curried functions', function() {
        f = flip((curry(function(a, b, c) {
          return a / (b / c);
        }))(2));
        f(3, 12).should.eql(8);
        return f(12)(3).should.eql(8);
      });
      return it('is commutative partially applied curried functions', function() {
        f = flip((f1 = (curry(function(a, b, c) {
          return a / (b / c);
        }))(2)));
        return flip(f).should.equal(f1);
      });
    });
  });

  describe('compose', function() {
    describe('(f2,f1)', function() {
      var f, f1, f2;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f = compose(f2, f1);
      it('is turned to f2(f1)', function() {
        return f(6, 4).should.eql(5);
      });
      return it('maintains arity for f1', function() {
        return arity(f).should.eql(2);
      });
    });
    return describe('(f3,f2,f1)', function() {
      var f, f1, f2, f3;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f3 = function(d) {
        return d / 3;
      };
      f = compose(f3, f2, f1);
      it('is turned to f3(f2(f1))', function() {
        return f(7, 5).should.eql(2);
      });
      return it('maintains arity for f1', function() {
        return arity(f).should.eql(2);
      });
    });
  });

  describe('sequence', function() {
    describe('(f1,f2)', function() {
      var f, f1, f2;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f = sequence(f1, f2);
      it('is turned to f2(f1)', function() {
        return f(6, 4).should.eql(5);
      });
      return it('maintains arity for f1', function() {
        return arity(f).should.eql(2);
      });
    });
    return describe('(f1,f2,f3)', function() {
      var f, f1, f2, f3;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f3 = function(d) {
        return d / 3;
      };
      f = sequence(f1, f2, f3);
      it('is turned to f3(f2(f1))', function() {
        return f(7, 5).should.eql(2);
      });
      return it('maintains arity for f1', function() {
        return arity(f).should.eql(2);
      });
    });
  });

  describe('I/ident', function() {
    it('returns the arg in', function() {
      return I(42).should.eql(42);
    });
    it('is of arity 1', function() {
      return arity(I).should.eql(1);
    });
    return it('ignores additional args', function() {
      return I(42, 2).should.eql(42);
    });
  });

  describe('tap', function() {
    var f;
    f = spy(I);
    it('is the mother of all side effect funcs', function() {
      tap(42, f).should.eql(42);
      return f.should.have.been.calledWith(42);
    });
    it('is curried', function() {
      return tap(f)(42).should.eql(42);
    });
    return it('has arity 2', function() {
      return tap.length.should.eql(2);
    });
  });

  foldfn = function(p, c) {
    return p + c / p;
  };

  FN_TEST = [
    {
      n: 'head',
      s: '[] -> undef',
      f: head,
      ar: 1,
      as: [[]],
      eq: void 0
    }, {
      n: 'head',
      s: '[a] -> a',
      f: head,
      ar: 1,
      as: [[1, 2, 3]],
      eq: 1
    }, {
      n: 'tail',
      s: '[] -> []',
      f: tail,
      ar: 1,
      as: [[]],
      eq: []
    }, {
      n: 'tail',
      s: '[a] -> [a]',
      f: tail,
      ar: 1,
      as: [[1, 2, 3]],
      eq: [2, 3]
    }, {
      n: 'last',
      s: '[] -> undef',
      f: last,
      ar: 1,
      as: [[]],
      eq: void 0
    }, {
      n: 'last',
      s: '[a] -> a',
      f: last,
      ar: 1,
      as: [[1, 2, 3]],
      eq: 3
    }, {
      n: 'concat',
      s: 'a, a -> [a]',
      f: concat,
      ar: 0,
      as: [0, 1, 2, 3],
      eq: [0, 1, 2, 3]
    }, {
      n: 'concat',
      s: '[a], a -> [a]',
      f: concat,
      ar: 0,
      as: [[0, 1], 2],
      eq: [0, 1, 2]
    }, {
      n: 'concat',
      s: 'a, [a] -> [a]',
      f: concat,
      ar: 0,
      as: [0, 1, [2, 3]],
      eq: [0, 1, 2, 3]
    }, {
      n: 'concat',
      s: '[a], [a] -> [a]',
      f: concat,
      ar: 0,
      as: [[0, 1], [2, 3]],
      eq: [0, 1, 2, 3]
    }, {
      n: 'each',
      s: '[a], fn -> undef',
      f: each,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a + 1;
        })
      ],
      eq: void 0
    }, {
      n: 'map',
      s: '[a], fn -> [a]',
      f: map,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a + 1;
        })
      ],
      eq: [1, 2, 3]
    }, {
      n: 'filter',
      s: '[a], fn -> [a]',
      f: filter,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a % 2;
        })
      ],
      eq: [1]
    }, {
      n: 'fold',
      s: '[a], fn, v -> *',
      f: fold,
      ar: 3,
      as: [[24, 28], foldfn, 12],
      eq: 16
    }, {
      n: 'fold1',
      s: '[a], fn -> *',
      f: fold1,
      ar: 2,
      as: [[12, 24, 28], foldfn],
      eq: 16
    }, {
      n: 'foldr',
      s: '[a], fn, v -> *',
      f: foldr,
      ar: 3,
      as: [[28, 24], foldfn, 12],
      eq: 16
    }, {
      n: 'foldr1',
      s: '[a], fn -> *',
      f: foldr1,
      ar: 2,
      as: [[28, 24, 12], foldfn],
      eq: 16
    }, {
      n: 'all',
      s: '[a], fn -> b',
      f: all,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a >= 0;
        })
      ],
      eq: true
    }, {
      n: 'any',
      s: '[a], fn -> b',
      f: any,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a > 1;
        })
      ],
      eq: true
    }, {
      n: 'join',
      s: '[a], s -> s',
      f: join,
      ar: 2,
      as: [[0, 1, 2], '-'],
      eq: '0-1-2'
    }, {
      n: 'reverse',
      s: '[a] -> [a]',
      f: reverse,
      ar: 1,
      as: [[0, 1, 2]],
      eq: [2, 1, 0]
    }, {
      n: 'split',
      s: 's, s -> s',
      f: split,
      ar: 2,
      as: ['a#b', '#'],
      eq: ['a', 'b']
    }, {
      n: 'match',
      s: 's, re -> null',
      f: match,
      ar: 2,
      as: ['abc', 'd'],
      eq: null
    }, {
      n: 'match',
      s: 's, s -> [s]',
      f: match,
      ar: 2,
      as: ['abc', 'b'],
      eq: 'abc'.match('b')
    }, {
      n: 'match',
      s: 's, re -> [s]',
      f: match,
      ar: 2,
      as: ['abc', /b/],
      eq: 'abc'.match(/b/)
    }, {
      n: 'replace',
      s: 's, s, s -> s',
      f: replace,
      ar: 3,
      as: ['aba', 'a', 'b'],
      eq: 'bba'
    }, {
      n: 'replace',
      s: 's, re, s -> s',
      f: replace,
      ar: 3,
      as: ['aba', /a/g, 'b'],
      eq: 'bbb'
    }, {
      n: 'search',
      s: 's, s -> b',
      f: search,
      ar: 2,
      as: ['aaaca', 'c'],
      eq: 3
    }, {
      n: 'search',
      s: 's, re -> b',
      f: search,
      ar: 2,
      as: ['aaaca', /ac/],
      eq: 2
    }, {
      n: 'trim',
      s: 's -> s',
      f: trim,
      ar: 1,
      as: ['  abc '],
      eq: 'abc'
    }, {
      n: 'ucase',
      s: 's -> s',
      f: ucase,
      ar: 1,
      as: ['abc'],
      eq: 'ABC'
    }, {
      n: 'lcase',
      s: 's -> s',
      f: lcase,
      ar: 1,
      as: ['ABC'],
      eq: 'abc'
    }, {
      n: 'sort',
      s: '[a], f -> [a]',
      f: sort,
      ar: 2,
      as: [[2, 3, 1], void 0],
      eq: [1, 2, 3]
    }, {
      n: 'sort',
      s: '[a], f -> [a]',
      f: sort,
      ar: 2,
      as: [
        [2, 3, 1], function(a, b) {
          return b - a;
        }
      ],
      eq: [3, 2, 1]
    }, {
      n: 'uniq',
      s: 'null -> null',
      f: uniq,
      ar: 1,
      as: [null],
      eq: null
    }, {
      n: 'uniq',
      s: '[a] -> [a]',
      f: uniq,
      ar: 1,
      as: [[]],
      eq: []
    }, {
      n: 'uniq',
      s: '[a] -> [a]',
      f: uniq,
      ar: 1,
      as: [[1, 2, 2, 1, 2, 3]],
      eq: [1, 2, 3]
    }, {
      n: 'index',
      s: '[a], a -> n',
      f: index,
      ar: 2,
      as: [[1, 2, 3, 4], 3],
      eq: 2
    }, {
      n: 'index',
      s: '[a], a -> n',
      f: index,
      ar: 2,
      as: [[1, 2, 3, 4], 5],
      eq: -1
    }, {
      n: 'contains',
      s: '[a], a -> b',
      f: contains,
      ar: 2,
      as: [[1, 2, 3, 4], 3],
      eq: true
    }, {
      n: 'contains',
      s: '[a], a -> b',
      f: contains,
      ar: 2,
      as: [[1, 2, 3, 4], 5],
      eq: false
    }, {
      n: 'has',
      s: '{k:v}, k -> b',
      f: has,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, 'b'
      ],
      eq: true
    }, {
      n: 'get',
      s: '{k:v}, k -> v',
      f: get,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, 'b'
      ],
      eq: 2
    }, {
      n: 'set',
      s: '{k:v}, k, v -> v',
      f: set,
      ar: 3,
      as: [
        {
          a: 1,
          b: 2
        }, 'b', 3
      ],
      eq: {
        a: 1,
        b: 3
      }
    }, {
      n: 'keys',
      s: '{k:v} -> [k]',
      f: keys,
      ar: 1,
      as: [
        {
          a: 1,
          b: 2
        }
      ],
      eq: ['a', 'b']
    }, {
      n: 'values',
      s: '{k:v} -> [v]',
      f: values,
      ar: 1,
      as: [
        {
          a: 1,
          b: 2
        }
      ],
      eq: [1, 2]
    }, {
      n: 'add',
      s: 'a, a -> a',
      f: add,
      ar: 2,
      as: [12, 2],
      eq: 14
    }, {
      n: 'add',
      s: 'a... -> a',
      f: add,
      ar: 2,
      as: [12, 2, 3],
      eq: 17
    }, {
      n: 'sub',
      s: 'a, a -> a',
      f: sub,
      ar: 2,
      as: [12, 2],
      eq: 10
    }, {
      n: 'sub',
      s: 'a... -> a',
      f: sub,
      ar: 2,
      as: [12, 2, 3],
      eq: 7
    }, {
      n: 'mul',
      s: 'a, a -> a',
      f: mul,
      ar: 2,
      as: [12, 2],
      eq: 24
    }, {
      n: 'mul',
      s: 'a... -> a',
      f: mul,
      ar: 2,
      as: [12, 2, 3],
      eq: 72
    }, {
      n: 'div',
      s: 'a, a -> a',
      f: div,
      ar: 2,
      as: [12, 2],
      eq: 6
    }, {
      n: 'div',
      s: 'a... -> a',
      f: div,
      ar: 2,
      as: [12, 2, 3],
      eq: 2
    }, {
      n: 'mod',
      s: 'a, a -> a',
      f: mod,
      ar: 2,
      as: [17, 6],
      eq: 5
    }, {
      n: 'mod',
      s: 'a... -> a',
      f: mod,
      ar: 2,
      as: [17, 6, 3],
      eq: 2
    }, {
      n: 'min',
      s: 'a, a -> a',
      f: min,
      ar: 2,
      as: [12, 2],
      eq: 2
    }, {
      n: 'min',
      s: 'a... -> a',
      f: min,
      ar: 2,
      as: [12, 3, 2],
      eq: 2
    }, {
      n: 'max',
      s: 'a, a -> a',
      f: max,
      ar: 2,
      as: [12, 2],
      eq: 12
    }, {
      n: 'max',
      s: 'a... -> a',
      f: max,
      ar: 2,
      as: [3, 2, 12],
      eq: 12
    }, {
      n: 'gt',
      s: 'a, a -> a',
      f: gt,
      ar: 2,
      as: [12, 11],
      eq: true
    }, {
      n: 'gt',
      s: 'a, a -> a',
      f: gt,
      ar: 2,
      as: [12, 12],
      eq: false
    }, {
      n: 'gte',
      s: 'a, a -> a',
      f: gte,
      ar: 2,
      as: [12, 12],
      eq: true
    }, {
      n: 'gte',
      s: 'a, a -> a',
      f: gte,
      ar: 2,
      as: [12, 13],
      eq: false
    }, {
      n: 'lt',
      s: 'a, a -> a',
      f: lt,
      ar: 2,
      as: [11, 12],
      eq: true
    }, {
      n: 'lt',
      s: 'a, a -> a',
      f: lt,
      ar: 2,
      as: [12, 12],
      eq: false
    }, {
      n: 'lte',
      s: 'a, a -> a',
      f: lte,
      ar: 2,
      as: [12, 12],
      eq: true
    }, {
      n: 'lte',
      s: 'a, a -> a',
      f: lte,
      ar: 2,
      as: [13, 12],
      eq: false
    }
  ];

  FN_TEST.forEach(function(spec) {
    return describe(spec.n, function() {
      it("has signature " + spec.s, function() {
        return expect(spec.f.apply(spec, spec.as)).to.eql(spec.eq);
      });
      if (spec.ar === spec.as.length) {
        if (spec.ar > 1) {
          it("has a curried variant", function() {
            if (spec.ar === 2) {
              return expect(spec.f(spec.as[1])(spec.as[0])).to.eql(spec.eq);
            } else if (spec.ar === 3) {
              return expect(spec.f(spec.as[2])(spec.as[1])(spec.as[0])).to.eql(spec.eq);
            }
          });
        }
        return it("is of arity(" + spec.ar + ")", function() {
          return spec.f.length.should.eql(spec.ar);
        });
      }
    });
  });

}).call(this);

//# sourceMappingURL=fnuc-test.js.map
