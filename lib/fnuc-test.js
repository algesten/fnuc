// Generated by CoffeeScript 1.8.0
(function() {
  var F, FN_TEST, Foo, TYPES, TYPE_ARR, TYPE_NO_PROTO, TYPE_PLAIN, TYPE_PROTO, assert, chai, date, eql, foldfn, mock, sandbox, sinon, spy, stub,
    __slice = [].slice;

  if (typeof browsertest !== "undefined" && browsertest !== null) {
    sinon = window.sinon;
    chai = window.chai;
    expect = window.chai.expect;
    F = window.F;
  } else {
    chai = require('chai');
    chai.use(require('sinon-chai'));
    sinon = require('sinon');
    F = require('../src/fnuc');
    delete global.__fnuc;
    F.expose(global);
  }

  assert = chai.assert;

  eql = assert.deepEqual;

  spy = sinon.spy, mock = sinon.mock, stub = sinon.stub, sandbox = sinon.sandbox;

  date = new Date(1421584085148);

  Foo = (function() {
    function Foo() {}

    return Foo;

  })();

  TYPES = [
    {
      v: void 0,
      t: 'undefined',
      d: '',
      truthy: false,
      func: false
    }, {
      v: null,
      t: 'null',
      d: '',
      truthy: false,
      func: false
    }, {
      v: false,
      t: 'boolean',
      d: '',
      truthy: false,
      func: false
    }, {
      v: true,
      t: 'boolean',
      d: '',
      truthy: true,
      func: false
    }, {
      v: '',
      t: 'string',
      d: '[empty]',
      truthy: false,
      func: String
    }, {
      v: 'str',
      t: 'string',
      d: '',
      truthy: true,
      func: String
    }, {
      v: 0,
      t: 'number',
      d: '[0]',
      truthy: false,
      func: Number
    }, {
      v: 42,
      t: 'number',
      d: '',
      truthy: true,
      func: Number
    }, {
      v: [],
      t: 'array',
      d: '[empty]',
      truthy: true,
      func: Array
    }, {
      v: [0, 1, {}],
      t: 'array',
      d: '',
      truthy: true,
      func: Array
    }, {
      v: date,
      t: 'date',
      d: '',
      truthy: true,
      func: Date
    }, {
      v: {},
      t: 'object',
      d: '[empty]',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: {
        a: 1,
        b: {}
      },
      t: 'object',
      d: '',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: new Foo,
      t: 'object',
      d: '[proto]',
      truthy: true,
      func: Object
    }, {
      v: {
        a: [
          {
            b: 1
          }
        ]
      },
      t: 'object',
      d: '',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: {
        a: [{}]
      },
      t: 'object',
      d: '',
      truthy: true,
      func: Object,
      plain: true
    }, {
      v: tuple({
        a: 1
      }, [1]),
      t: 'tuple',
      d: '',
      truthy: true,
      func: Object
    }, {
      v: tuple(2, 3),
      t: 'tuple',
      d: '',
      truthy: true,
      func: Object
    }
  ];

  TYPE_PROTO = TYPES.filter(function(spec) {
    return spec.t === 'object' && !spec.plain;
  });

  TYPE_NO_PROTO = TYPES.filter(function(spec) {
    return spec.t !== 'object' || spec.plain;
  });

  TYPE_ARR = TYPES.filter(function(spec) {
    return spec.t === 'array';
  });

  TYPE_PLAIN = TYPES.filter(function(spec) {
    return spec.t === 'object' && spec.plain;
  });

  describe('type', function() {
    return describe('for 1 arg', function() {
      return TYPES.forEach(function(spec) {
        return it("works for " + spec.t + spec.d, function() {
          return eql(type(spec.v), spec.t);
        });
      });
    });
  });

  describe('typeis', function() {
    describe('works on the form (a,s)', function() {
      return TYPES.forEach(function(spec) {
        return it("for type " + spec.t + spec.d, function() {
          return eql(typeis(spec.v, spec.t), true);
        });
      });
    });
    return describe('works curried (s)(a)', function() {
      return TYPES.forEach(function(spec) {
        return it("for type " + spec.t + spec.d, function() {
          return eql(typeis(spec.t)(spec.v), true);
        });
      });
    });
  });

  describe('isplain', function() {
    return describe('tells whether something is a plain object', function() {
      return TYPES.forEach(function(spec) {
        return it("for type " + spec.t + spec.d, function() {
          return eql(isplain(spec.v), !!spec.plain);
        });
      });
    });
  });

  describe('merge', function() {
    return describe('alters first argument with consecutive and', function() {
      it('handles no object', function() {
        return eql(merge(), void 0);
      });
      it('handles one object', function() {
        return eql(merge({
          a: 1
        }), {
          a: 1
        });
      });
      it('handles two objects', function() {
        return eql(merge({
          a: 1
        }, {
          b: 2
        }), {
          a: 1,
          b: 2
        });
      });
      it('handles three objects', function() {
        return eql(merge({
          a: 1
        }, {
          b: 2
        }, {
          c: 3
        }), {
          a: 1,
          b: 2,
          c: 3
        });
      });
      it('overwrites existing keys', function() {
        return eql(merge({
          a: 1
        }, {
          a: 2
        }), {
          a: 2
        });
      });
      it('overwrites with precedence', function() {
        return eql(merge({
          a: 1
        }, {
          a: 2
        }, {
          a: 3
        }), {
          a: 3
        });
      });
      it('ignores undefined values', function() {
        return eql(merge({
          a: 1
        }, {
          a: void 0
        }), {
          a: 1
        });
      });
      return it('leaves undefined in first be', function() {
        return eql(merge({
          a: void 0
        }, {
          b: 2
        }), {
          a: void 0,
          b: 2
        });
      });
    });
  });

  describe('mixin', function() {
    return describe('returns a new object with all arguments merged and', function() {
      it('handles no object', function() {
        return eql(mixin(), {});
      });
      it('handles one object', function() {
        var a, r;
        eql((r = mixin(a = {
          a: 1
        })), {
          a: 1
        });
        return assert.ok(a !== r);
      });
      it('handles two objects', function() {
        var a;
        eql(mixin(a = {
          a: 1
        }, {
          b: 2
        }), {
          a: 1,
          b: 2
        });
        return eql(a, {
          a: 1
        });
      });
      it('handles three objects', function() {
        var a;
        eql(mixin(a = {
          a: 1
        }, {
          b: 2
        }, {
          c: 3
        }), {
          a: 1,
          b: 2,
          c: 3
        });
        return eql(a, {
          a: 1
        });
      });
      it('overwrites existing keys', function() {
        var a;
        eql(mixin(a = {
          a: 1
        }, {
          a: 2
        }), {
          a: 2
        });
        return eql(a, {
          a: 1
        });
      });
      it('overwrites with precedence', function() {
        var a;
        eql(mixin(a = {
          a: 1
        }, {
          a: 2
        }, {
          a: 3
        }), {
          a: 3
        });
        return eql(a, {
          a: 1
        });
      });
      it('ignores undefined values', function() {
        var a;
        eql(mixin(a = {
          a: 1
        }, {
          a: void 0
        }), {
          a: 1
        });
        return eql(a, {
          a: 1
        });
      });
      return it('leaves undefined in first be', function() {
        var a;
        eql(mixin(a = {
          a: void 0
        }, {
          b: 2
        }), {
          b: 2
        });
        return eql(a, {
          a: void 0
        });
      });
    });
  });

  describe('shallow', function() {
    describe('does a shallow copy', function() {
      return TYPE_NO_PROTO.forEach(function(spec) {
        return it("for built in type " + spec.t + spec.d, function() {
          var r;
          r = shallow(spec.v);
          return eql(r, spec.v);
        });
      });
    });
    describe('wont handle proto', function() {
      return TYPE_PROTO.forEach(function(spec) {
        return it('throws an exception', function() {
          return assert.throws((function() {
            return shallow(spec.v);
          }), 'Can\'t shallow [object Object]');
        });
      });
    });
    return describe('specifically', function() {
      describe('for arrays', function() {
        return TYPE_ARR.forEach(function(spec) {
          return it("copies nested by reference for " + spec.t + spec.d, function() {
            var a, i, r, _i, _len;
            r = shallow(spec.v);
            assert.ok(r !== spec.v);
            for (i = _i = 0, _len = r.length; _i < _len; i = ++_i) {
              a = r[i];
              assert.ok(r[i] === spec.v[i]);
            }
            return eql(r.length, spec.v.length);
          });
        });
      });
      return describe('for objects', function() {
        return TYPE_PLAIN.forEach(function(spec) {
          return it("copies nested by reference for " + spec.t + spec.d, function() {
            var k, r, v;
            r = shallow(spec.v);
            assert.ok(r !== spec.v);
            for (k in r) {
              v = r[k];
              assert.ok(v === spec.v[k]);
            }
            return eql(Object.keys(r).length, Object.keys(spec.v).length);
          });
        });
      });
    });
  });

  describe('clone', function() {
    describe('does a deep copy', function() {
      return TYPE_NO_PROTO.forEach(function(spec) {
        return it("for built in type " + spec.t + spec.d, function() {
          var r;
          r = clone(spec.v);
          return eql(r, spec.v);
        });
      });
    });
    describe('wont handle proto', function() {
      return TYPE_PROTO.forEach(function(spec) {
        return it('throws an exception', function() {
          return assert.throws((function() {
            return clone(spec.v);
          }), 'Can\'t shallow [object Object]');
        });
      });
    });
    return describe('specifically', function() {
      describe('for arrays', function() {
        return TYPE_ARR.forEach(function(spec) {
          return it("clones nested for " + spec.t + spec.d, function() {
            var a, i, r, _i, _len;
            r = clone(spec.v);
            assert.ok(r !== spec.v);
            for (i = _i = 0, _len = r.length; _i < _len; i = ++_i) {
              a = r[i];
              if (typeis(a, 'number')) {
                assert.ok(r[i] === spec.v[i]);
              } else {
                assert.ok(r[i] !== spec.v[i]);
              }
            }
            return eql(r.length, spec.v.length);
          });
        });
      });
      return describe('for objects', function() {
        return TYPE_PLAIN.forEach(function(spec) {
          return it("clones nested for " + spec.t + spec.d, function() {
            var k, r, v;
            r = clone(spec.v);
            assert.ok(r !== spec.v);
            for (k in r) {
              v = r[k];
              if (typeis(v, 'number')) {
                assert.ok(v === spec.v[k]);
              } else {
                assert.ok(v !== spec.v[k]);
              }
            }
            return eql(Object.keys(r).length, Object.keys(spec.v).length);
          });
        });
      });
    });
  });

  describe('arity', function() {
    it('returns the arity of (f)', function() {
      eql(arity(function() {}), 0);
      eql(arity(function(a) {}), 1);
      return eql(arity(function(a, b) {}), 2);
    });
    it('chops the arity to the given number if (f,n)', function() {
      var n, _i, _results;
      _results = [];
      for (n = _i = 0; _i <= 10; n = ++_i) {
        _results.push(eql(arity(arity((function(a, b, c) {}), n)), n));
      }
      return _results;
    });
    it('has a curried variant for (n)', function() {
      var n, _i, _results;
      _results = [];
      for (n = _i = 0; _i <= 10; n = ++_i) {
        _results.push(eql(arity(arity(n)(function(a, b, c) {})), n));
      }
      return _results;
    });
    describe('unary', function() {
      return it('is arity(1)', function() {
        var f;
        f = unary((function(a, b, c, d, e) {}));
        return eql(f.length, 1);
      });
    });
    describe('binary', function() {
      return it('is arity(2)', function() {
        var f;
        f = binary(function(a, b, c, d, e) {});
        return eql(f.length, 2);
      });
    });
    return describe('ternary', function() {
      return it('is arity(3)', function() {
        var f;
        f = ternary(function(a, b, c, d, e) {});
        return eql(f.length, 3);
      });
    });
  });

  describe('partial', function() {
    return describe('partially fills in arguments from the left', function() {
      it('executes arity(0)', function() {
        var r;
        r = partial((function() {
          return 42;
        }));
        return eql(r, 42);
      });
      it('executes arity(0) with arguments', function() {
        var r;
        r = partial((function() {
          return 42;
        }), 1, 2, 3);
        return eql(r, 42);
      });
      it('handles arity(1)', function() {
        var r;
        r = partial((function(a) {
          return a + 42;
        }));
        assert.isFunction(r);
        return eql(r(1, 2, 3), 43);
      });
      it('executes arity(1) with arguments', function() {
        var r;
        r = partial((function(a) {
          return a + 42;
        }), 1, 2);
        assert.isNotFunction(r);
        return eql(r, 43);
      });
      it('works for arity(2)', function() {
        var r;
        r = partial((function(a, b) {
          return a / b;
        }), 42);
        assert.isFunction(r);
        eql(arity(r), 1);
        return eql(r(2, 3, 4), 21);
      });
      it('executes arity(2) with arguments', function() {
        var r;
        r = partial((function(a, b) {
          return a / b;
        }), 42, 2);
        assert.isNotFunction(r);
        return eql(r, 21);
      });
      it('works for arity(3) with one arg', function() {
        var r;
        r = partial((function(a, b, c) {
          return a / (b / c);
        }), 12);
        assert.isFunction(r);
        eql(arity(r), 2);
        return eql(r(3, 2, 5), 8);
      });
      it('works for arity(3) with two arg', function() {
        var r;
        r = partial((function(a, b, c) {
          return a / (b / c);
        }), 12, 3);
        assert.isFunction(r);
        eql(arity(r), 1);
        return eql(r(2, 5), 8);
      });
      return it('executes arity(3) with arguments', function() {
        var r;
        r = partial((function(a, b, c) {
          return a / (b / c);
        }), 12, 3, 2, 5);
        assert.isNotFunction(r);
        return eql(r, 8);
      });
    });
  });

  describe('partialr', function() {
    return describe('partially fills in arguments from the right', function() {
      it('executes arity(0)', function() {
        var r;
        r = partialr((function() {
          return 42;
        }));
        return eql(r, 42);
      });
      it('executes arity(0) with arguments', function() {
        var r;
        r = partialr((function() {
          return 42;
        }), 1, 2, 3);
        return eql(r, 42);
      });
      it('handles arity(1)', function() {
        var r;
        r = partialr((function(a) {
          return a + 42;
        }));
        assert.isFunction(r);
        return eql(r(1, 2, 3), 43);
      });
      it('executes arity(1) with arguments', function() {
        var r;
        r = partialr((function(a) {
          return a + 42;
        }), 1, 2);
        assert.isNotFunction(r);
        return eql(r, 43);
      });
      it('works for arity(2)', function() {
        var r;
        r = partialr((function(a, b) {
          return a / b;
        }), 2);
        assert.isFunction(r);
        eql(arity(r), 1);
        return eql(r(42, 3, 4), 21);
      });
      it('executes arity(2) with arguments', function() {
        var r;
        r = partialr((function(a, b) {
          return a / b;
        }), 42, 2);
        assert.isNotFunction(r);
        return eql(r, 21);
      });
      it('works for arity(3) with one arg', function() {
        var r;
        r = partialr((function(a, b, c) {
          return a / (b / c);
        }), 2);
        assert.isFunction(r);
        eql(arity(r), 2);
        return eql(r(12, 3, 5), 8);
      });
      it('works for arity(3) with two arg', function() {
        var r;
        r = partialr((function(a, b, c) {
          return a / (b / c);
        }), 3, 2);
        assert.isFunction(r);
        eql(arity(r), 1);
        return eql(r(12, 5), 8);
      });
      return it('executes arity(3) with arguments', function() {
        var r;
        r = partialr((function(a, b, c) {
          return a / (b / c);
        }), 12, 3, 2, 5);
        assert.isNotFunction(r);
        return eql(r, 8);
      });
    });
  });

  describe('curry', function() {
    it('does nothing for arity(f) == 0', function() {
      var f, g;
      f = function() {};
      g = curry(f);
      return assert.ok(g === f);
    });
    it('does nothing for arity(f) == 1', function() {
      var f, g;
      f = function(n) {};
      g = curry(f);
      return assert.ok(g === f);
    });
    describe('(a,b) ->', function() {
      var div;
      div = curry(function(a, b) {
        return a / b;
      });
      it('turns to (b) -> (a) ->', function() {
        var div2;
        div2 = div(2);
        return eql(div2(10), 5);
      });
      it('maintains arity for curried func', function() {
        return eql(arity(div), 2);
      });
      it('returns a smaller arity func after partial apply', function() {
        var div2;
        div2 = div(2);
        return eql(arity(div2), 1);
      });
      return it('can still apply (a,b) to curried (a,b) ->', function() {
        return eql(div(10, 2), 5);
      });
    });
    return describe('(a,b,c) ->', function() {
      var divt;
      divt = curry(function(a, b, c) {
        return a / (b / c);
      });
      it('turns to (c) -> (b) -> (a) ->', function() {
        var div2, div4;
        div2 = divt(2);
        div4 = div2(8);
        return eql(div4(80), 20);
      });
      it('maintains arity for curried func', function() {
        return eql(arity(divt), 3);
      });
      it('returns a small arity func after partial apply', function() {
        var div2, div4;
        div2 = divt(2);
        div4 = div2(8);
        eql(arity(div2), 2);
        return eql(arity(div4), 1);
      });
      it('can be partially applied with (b,c)', function() {
        var div4;
        div4 = divt(8, 2);
        return eql(div4(80), 20);
      });
      it('does correct arity for partial applied', function() {
        var div4;
        div4 = divt(8, 2);
        return eql(arity(div4), 1);
      });
      it('can still apply (a,b,c) to curried (a,b,c) ->', function() {
        return eql(divt(80, 8, 2), 20);
      });
      it('can apply (b,c) to partial applied curried (a,b,c) ->', function() {
        var div2;
        div2 = divt(2);
        return eql(div2(80, 8), 20);
      });
      return it('doesnt splice in more arguments for a partially applied', function() {
        var div2;
        div2 = divt(2);
        return eql(div2(100, 25, 4), 8);
      });
    });
  });

  describe('flip', function() {
    describe('(a,b) ->', function() {
      var f, f1;
      f = flip((f1 = function(a, b) {
        return a / b;
      }));
      it('flips the arguments to (b,a) ->', function() {
        return eql(f(2, 10), 5);
      });
      it('keeps arity', function() {
        return eql(arity(f), 2);
      });
      it('is commutative', function() {
        return assert.ok(flip(f) === f1);
      });
      it('flips curried functions', function() {
        f = flip(curry(function(a, b) {
          return a / b;
        }));
        eql(f(2, 10), 5);
        return eql(f(10)(2), 5);
      });
      it('is commutative for curried functions', function() {
        f = flip((f1 = curry(function(a, b) {
          return a / b;
        })));
        return assert.ok(flip(f) === f1);
      });
      it('flips partially applied curried functions', function() {
        f = flip((curry(function(a, b) {
          return a / b;
        }))(2));
        return eql(f(8), 4);
      });
      return it('is commutative for partially applied curried functions', function() {
        f = flip((f1 = (curry(function(a, b) {
          return a / b;
        }))(2)));
        return assert.ok(flip(f), f1);
      });
    });
    return describe('(a,b,c) ->', function() {
      var f, f1;
      f = flip((f1 = function(a, b, c) {
        return a / (b / c);
      }));
      it('flips the arguments to (c,b,a) ->', function() {
        return eql(f(2, 3, 12), 8);
      });
      it('keeps arity', function() {
        return eql(arity(f), 3);
      });
      it('is commutative', function() {
        return eql(flip(f), f1);
      });
      it('flips curried functions', function() {
        f = flip(curry(function(a, b, c) {
          return a / (b / c);
        }));
        eql(f(2, 3, 12), 8);
        return eql(f(12)(3)(2), 8);
      });
      it('is commutative for curried functions', function() {
        f = flip((f1 = curry(function(a, b, c) {
          return a / (b / c);
        })));
        return assert.ok(flip(f) === f1);
      });
      it('flips partially applied curried functions', function() {
        f = flip((curry(function(a, b, c) {
          return a / (b / c);
        }))(2));
        eql(f(3, 12), 8);
        return eql(f(12)(3), 8);
      });
      return it('is commutative partially applied curried functions', function() {
        f = flip((f1 = (curry(function(a, b, c) {
          return a / (b / c);
        }))(2)));
        return assert.ok(flip(f) === f1);
      });
    });
  });

  describe('compose', function() {
    describe('(f2,f1)', function() {
      var f, f1, f2;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f = compose(f2, f1);
      it('is turned to f2(f1)', function() {
        return eql(f(6, 4), 5);
      });
      return it('maintains arity for f1', function() {
        return eql(arity(f), 2);
      });
    });
    return describe('(f3,f2,f1)', function() {
      var f, f1, f2, f3;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f3 = function(d) {
        return d / 3;
      };
      f = compose(f3, f2, f1);
      it('is turned to f3(f2(f1))', function() {
        return eql(f(7, 5), 2);
      });
      return it('maintains arity for f1', function() {
        return eql(arity(f), 2);
      });
    });
  });

  describe('sequence', function() {
    describe('(f1,f2)', function() {
      var f, f1, f2;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f = sequence(f1, f2);
      it('is turned to f2(f1)', function() {
        return eql(f(6, 4), 5);
      });
      return it('maintains arity for f1', function() {
        return eql(arity(f), 2);
      });
    });
    return describe('(f1,f2,f3)', function() {
      var f, f1, f2, f3;
      f1 = function(a, b) {
        return a + b;
      };
      f2 = function(c) {
        return c / 2;
      };
      f3 = function(d) {
        return d / 3;
      };
      f = sequence(f1, f2, f3);
      it('is turned to f3(f2(f1))', function() {
        return eql(f(7, 5), 2);
      });
      return it('maintains arity for f1', function() {
        return eql(arity(f), 2);
      });
    });
  });

  describe('I/ident', function() {
    it('returns the arg in', function() {
      return eql(I(42), 42);
    });
    it('is of arity 1', function() {
      return eql(arity(I), 1);
    });
    return it('ignores additional args', function() {
      return eql(I(42, 2), 42);
    });
  });

  describe('tap', function() {
    var f;
    f = spy(I);
    it('is the mother of all side effect funcs', function() {
      eql(tap(42, f), 42);
      return eql(f.args[0], [42]);
    });
    it('is curried', function() {
      return eql(tap(f)(42), 42);
    });
    return it('has arity 2', function() {
      return eql(tap.length, 2);
    });
  });

  foldfn = function(p, c) {
    return p + c / p;
  };

  FN_TEST = [
    {
      n: 'head',
      s: '[] -> undef',
      f: head,
      ar: 1,
      as: [[]],
      eq: void 0
    }, {
      n: 'head',
      s: '[a] -> a',
      f: head,
      ar: 1,
      as: [[1, 2, 3]],
      eq: 1
    }, {
      n: 'tail',
      s: '[] -> []',
      f: tail,
      ar: 1,
      as: [[]],
      eq: []
    }, {
      n: 'tail',
      s: '[a] -> [a]',
      f: tail,
      ar: 1,
      as: [[1, 2, 3]],
      eq: [2, 3]
    }, {
      n: 'last',
      s: '[] -> undef',
      f: last,
      ar: 1,
      as: [[]],
      eq: void 0
    }, {
      n: 'last',
      s: '[a] -> a',
      f: last,
      ar: 1,
      as: [[1, 2, 3]],
      eq: 3
    }, {
      n: 'concat',
      s: 'a, a -> [a]',
      f: concat,
      ar: 0,
      as: [0, 1, 2, 3],
      eq: [0, 1, 2, 3]
    }, {
      n: 'concat',
      s: '[a], a -> [a]',
      f: concat,
      ar: 0,
      as: [[0, 1], 2],
      eq: [0, 1, 2]
    }, {
      n: 'concat',
      s: 'a, [a] -> [a]',
      f: concat,
      ar: 0,
      as: [0, 1, [2, 3]],
      eq: [0, 1, 2, 3]
    }, {
      n: 'concat',
      s: '[a], [a] -> [a]',
      f: concat,
      ar: 0,
      as: [[0, 1], [2, 3]],
      eq: [0, 1, 2, 3]
    }, {
      n: 'each',
      s: '[a], fn -> undef',
      f: each,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a + 1;
        })
      ],
      eq: void 0
    }, {
      n: 'map',
      s: '[a], fn -> [a]',
      f: map,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a + 1;
        })
      ],
      eq: [1, 2, 3]
    }, {
      n: 'filter',
      s: '[a], fn -> [a]',
      f: filter,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a % 2;
        })
      ],
      eq: [1]
    }, {
      n: 'fold',
      s: '[a], fn, v -> *',
      f: fold,
      ar: 3,
      as: [[24, 28], foldfn, 12],
      eq: 16
    }, {
      n: 'fold1',
      s: '[a], fn -> *',
      f: fold1,
      ar: 2,
      as: [[12, 24, 28], foldfn],
      eq: 16
    }, {
      n: 'foldr',
      s: '[a], fn, v -> *',
      f: foldr,
      ar: 3,
      as: [[28, 24], foldfn, 12],
      eq: 16
    }, {
      n: 'foldr1',
      s: '[a], fn -> *',
      f: foldr1,
      ar: 2,
      as: [[28, 24, 12], foldfn],
      eq: 16
    }, {
      n: 'all',
      s: '[a], fn -> b',
      f: all,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a >= 0;
        })
      ],
      eq: true
    }, {
      n: 'any',
      s: '[a], fn -> b',
      f: any,
      ar: 2,
      as: [
        [0, 1, 2], (function(a) {
          return a > 1;
        })
      ],
      eq: true
    }, {
      n: 'join',
      s: '[a], s -> s',
      f: join,
      ar: 2,
      as: [[0, 1, 2], '-'],
      eq: '0-1-2'
    }, {
      n: 'reverse',
      s: '[a] -> [a]',
      f: reverse,
      ar: 1,
      as: [[0, 1, 2]],
      eq: [2, 1, 0]
    }, {
      n: 'split',
      s: 's, s -> s',
      f: split,
      ar: 2,
      as: ['a#b', '#'],
      eq: ['a', 'b']
    }, {
      n: 'match',
      s: 's, re -> null',
      f: match,
      ar: 2,
      as: ['abc', 'd'],
      eq: null
    }, {
      n: 'match',
      s: 's, s -> [s]',
      f: match,
      ar: 2,
      as: ['abc', 'b'],
      eq: 'abc'.match('b')
    }, {
      n: 'match',
      s: 's, re -> [s]',
      f: match,
      ar: 2,
      as: ['abc', /b/],
      eq: 'abc'.match(/b/)
    }, {
      n: 'replace',
      s: 's, s, s -> s',
      f: replace,
      ar: 3,
      as: ['aba', 'a', 'b'],
      eq: 'bba'
    }, {
      n: 'replace',
      s: 's, re, s -> s',
      f: replace,
      ar: 3,
      as: ['aba', /a/g, 'b'],
      eq: 'bbb'
    }, {
      n: 'search',
      s: 's, s -> b',
      f: search,
      ar: 2,
      as: ['aaaca', 'c'],
      eq: 3
    }, {
      n: 'search',
      s: 's, re -> b',
      f: search,
      ar: 2,
      as: ['aaaca', /ac/],
      eq: 2
    }, {
      n: 'slice',
      s: 's, n, n -> s',
      f: slice,
      ar: 3,
      as: ['abcdef', 1, 3],
      eq: 'bc'
    }, {
      n: 'drop',
      s: 's, n -> s',
      f: drop,
      ar: 2,
      as: ['abcdef', 2],
      eq: 'cdef'
    }, {
      n: 'take',
      s: 's, n -> s',
      f: take,
      ar: 2,
      as: ['abcdef', 2],
      eq: 'ab'
    }, {
      n: 'trim',
      s: 's -> s',
      f: trim,
      ar: 1,
      as: ['  abc '],
      eq: 'abc'
    }, {
      n: 'ucase',
      s: 's -> s',
      f: ucase,
      ar: 1,
      as: ['abc'],
      eq: 'ABC'
    }, {
      n: 'lcase',
      s: 's -> s',
      f: lcase,
      ar: 1,
      as: ['ABC'],
      eq: 'abc'
    }, {
      n: 'sort',
      s: '[a], f -> [a]',
      f: sort,
      ar: 2,
      as: [[2, 3, 1], void 0],
      eq: [1, 2, 3]
    }, {
      n: 'sort',
      s: '[a], f -> [a]',
      f: sort,
      ar: 2,
      as: [
        [2, 3, 1], function(a, b) {
          return b - a;
        }
      ],
      eq: [3, 2, 1]
    }, {
      n: 'uniq',
      s: 'null -> null',
      f: uniq,
      ar: 1,
      as: [null],
      eq: null
    }, {
      n: 'uniq',
      s: '[a] -> [a]',
      f: uniq,
      ar: 1,
      as: [[]],
      eq: []
    }, {
      n: 'uniq',
      s: '[a] -> [a]',
      f: uniq,
      ar: 1,
      as: [[1, 2, 2, 1, 2, 3]],
      eq: [1, 2, 3]
    }, {
      n: 'index',
      s: '[a], a -> n',
      f: index,
      ar: 2,
      as: [[1, 2, 3, 4], 3],
      eq: 2
    }, {
      n: 'index',
      s: '[a], a -> n',
      f: index,
      ar: 2,
      as: [[1, 2, 3, 4], 5],
      eq: -1
    }, {
      n: 'contains',
      s: '[a], a -> b',
      f: contains,
      ar: 2,
      as: [[1, 2, 3, 4], 3],
      eq: true
    }, {
      n: 'contains',
      s: '[a], a -> b',
      f: contains,
      ar: 2,
      as: [[1, 2, 3, 4], 5],
      eq: false
    }, {
      n: 'has',
      s: '{k:v}, k -> b',
      f: has,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, 'b'
      ],
      eq: true
    }, {
      n: 'get',
      s: '{k:v}, k -> v',
      f: get,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, 'b'
      ],
      eq: 2
    }, {
      n: 'set',
      s: '{k:v}, k, v -> v',
      f: set,
      ar: 3,
      as: [
        {
          a: 1,
          b: 2
        }, 'b', 3
      ],
      eq: {
        a: 1,
        b: 3
      }
    }, {
      n: 'keys',
      s: '{k:v} -> [k]',
      f: keys,
      ar: 1,
      as: [
        {
          a: 1,
          b: 2
        }
      ],
      eq: ['a', 'b']
    }, {
      n: 'values',
      s: '{k:v} -> [v]',
      f: values,
      ar: 1,
      as: [
        {
          a: 1,
          b: 2
        }
      ],
      eq: [1, 2]
    }, {
      n: 'add',
      s: 'a, a -> a',
      f: add,
      ar: 2,
      as: [12, 2],
      eq: 14
    }, {
      n: 'add',
      s: 'a... -> a',
      f: add,
      ar: 2,
      as: [12, 2, 3],
      eq: 17
    }, {
      n: 'sub',
      s: 'a, a -> a',
      f: sub,
      ar: 2,
      as: [12, 2],
      eq: 10
    }, {
      n: 'sub',
      s: 'a... -> a',
      f: sub,
      ar: 2,
      as: [12, 2, 3],
      eq: 7
    }, {
      n: 'mul',
      s: 'a, a -> a',
      f: mul,
      ar: 2,
      as: [12, 2],
      eq: 24
    }, {
      n: 'mul',
      s: 'a... -> a',
      f: mul,
      ar: 2,
      as: [12, 2, 3],
      eq: 72
    }, {
      n: 'div',
      s: 'a, a -> a',
      f: div,
      ar: 2,
      as: [12, 2],
      eq: 6
    }, {
      n: 'div',
      s: 'a... -> a',
      f: div,
      ar: 2,
      as: [12, 2, 3],
      eq: 2
    }, {
      n: 'mod',
      s: 'a, a -> a',
      f: mod,
      ar: 2,
      as: [17, 6],
      eq: 5
    }, {
      n: 'mod',
      s: 'a... -> a',
      f: mod,
      ar: 2,
      as: [17, 6, 3],
      eq: 2
    }, {
      n: 'min',
      s: 'a, a -> a',
      f: min,
      ar: 2,
      as: [12, 2],
      eq: 2
    }, {
      n: 'min',
      s: 'a... -> a',
      f: min,
      ar: 2,
      as: [12, 3, 2],
      eq: 2
    }, {
      n: 'max',
      s: 'a, a -> a',
      f: max,
      ar: 2,
      as: [12, 2],
      eq: 12
    }, {
      n: 'max',
      s: 'a... -> a',
      f: max,
      ar: 2,
      as: [3, 2, 12],
      eq: 12
    }, {
      n: 'gt',
      s: 'a, a -> a',
      f: gt,
      ar: 2,
      as: [12, 11],
      eq: true
    }, {
      n: 'gt',
      s: 'a, a -> a',
      f: gt,
      ar: 2,
      as: [12, 12],
      eq: false
    }, {
      n: 'gte',
      s: 'a, a -> a',
      f: gte,
      ar: 2,
      as: [12, 12],
      eq: true
    }, {
      n: 'gte',
      s: 'a, a -> a',
      f: gte,
      ar: 2,
      as: [12, 13],
      eq: false
    }, {
      n: 'lt',
      s: 'a, a -> a',
      f: lt,
      ar: 2,
      as: [11, 12],
      eq: true
    }, {
      n: 'lt',
      s: 'a, a -> a',
      f: lt,
      ar: 2,
      as: [12, 12],
      eq: false
    }, {
      n: 'lte',
      s: 'a, a -> a',
      f: lte,
      ar: 2,
      as: [12, 12],
      eq: true
    }, {
      n: 'lte',
      s: 'a, a -> a',
      f: lte,
      ar: 2,
      as: [13, 12],
      eq: false
    }, {
      n: 'eq',
      s: 'a, a -> b',
      f: eq,
      ar: 2,
      as: [0, 0],
      eq: true
    }, {
      n: 'eq',
      s: 'a, a -> b',
      f: eq,
      ar: 2,
      as: [1, 0],
      eq: false
    }, {
      n: 'eq',
      s: 'a, a -> b',
      f: eq,
      ar: 2,
      as: [{}, {}],
      eq: false
    }, {
      n: 'eq',
      s: 'a... -> b',
      f: eq,
      ar: 2,
      as: [1, 1, 2],
      eq: false
    }, {
      n: 'eq',
      s: 'a... -> b',
      f: eq,
      ar: 2,
      as: [false, false, false],
      eq: true
    }, {
      n: 'eq',
      s: 'a... -> b',
      f: eq,
      ar: 2,
      as: [0, 0, 1],
      eq: false
    }, {
      n: 'not',
      s: 'a..., a -> b',
      f: nnot,
      ar: 2,
      as: [false, I],
      eq: true
    }, {
      n: 'not',
      s: 'a..., a -> b',
      f: nnot,
      ar: 2,
      as: [
        0, 1, function(a, b) {
          return b === 1;
        }
      ],
      eq: false
    }, {
      n: 'pick',
      s: '{k:v}, [k] -> {k:v}',
      f: pick,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, ['b', 'c']
      ],
      eq: {
        b: 2,
        c: 3
      }
    }, {
      n: 'pick',
      s: '{k:v}, k -> {k:v}',
      f: pick,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, 'b', 'c'
      ],
      eq: {
        b: 2,
        c: 3
      }
    }, {
      n: 'pick',
      s: '{k:v}, k -> {k:v}',
      f: pick,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, 'b'
      ],
      eq: {
        b: 2
      }
    }, {
      n: 'evolve',
      s: '{k:v}, {k:(v->v)} -> {k:v}',
      f: evolve,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, {}
      ],
      eq: {
        a: 1,
        b: 2
      }
    }, {
      n: 'evolve',
      s: '{k:v}, {k:(v->v)} -> {k:v}',
      f: evolve,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2
        }, {
          a: function(v) {
            return v + 1;
          }
        }
      ],
      eq: {
        a: 2,
        b: 2
      }
    }, {
      n: 'omap',
      s: '{k:v}, ((k,v) -> v) -> {k:v}',
      f: omap,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, function(k, v) {
          if (k === 'b') {
            return v + 40;
          } else {
            return v;
          }
        }
      ],
      eq: {
        a: 1,
        b: 42,
        c: 3
      }
    }, {
      n: 'ofilter',
      s: '{k:v}, ((k,v) -> Boolean) -> {k:v}',
      f: ofilter,
      ar: 2,
      as: [
        {
          a: 1,
          b: 2,
          c: 3
        }, function(k, v) {
          return k === 'b';
        }
      ],
      eq: {
        b: 2
      }
    }
  ];

  FN_TEST.forEach(function(spec) {
    return describe(spec.n, function() {
      it("has signature " + spec.s, function() {
        return eql(spec.f.apply(spec, spec.as), spec.eq);
      });
      if (spec.ar === spec.as.length) {
        if (spec.ar > 1) {
          it("has a curried variant", function() {
            if (spec.ar === 2) {
              return eql(spec.f(spec.as[1])(spec.as[0]), spec.eq);
            } else if (spec.ar === 3) {
              return eql(spec.f(spec.as[2])(spec.as[1])(spec.as[0]), spec.eq);
            }
          });
        }
        return it("is of arity(" + spec.ar + ")", function() {
          return eql(spec.f.length, spec.ar);
        });
      }
    });
  });

  describe('map', function() {
    var as;
    as = split('abc', '');
    return it('doesnt pass multiple args to map function', function() {
      return map(as, function(v, i, as) {
        eql(i, void 0);
        eql(as, void 0);
        return v;
      });
    });
  });

  describe('fold/fold1/foldr/foldr1', function() {
    var as, fs;
    fs = [fold, fold1, foldr, foldr1];
    as = [0, 1, 2, 3];
    return each(fs, function(f) {
      return it('doesnt pass multiple args to fold function', function() {
        return f(as, (function(p, c, i, as) {
          eql(i, void 0);
          eql(as, void 0);
          return p + c;
        }), 1);
      });
    });
  });

  describe('and', function() {
    var even, gt10, lt102;
    gt10 = even = lt102 = null;
    beforeEach(function() {
      gt10 = spy(gt(10));
      even = spy(function(n) {
        return n % 2 === 0;
      });
      return lt102 = spy(lt(102));
    });
    it('is of arity(2)', function() {
      return eql(arity(aand), 2);
    });
    it('wraps two functions f, g and invokes both with &&', function() {
      var f;
      f = aand(gt10, even);
      eql(f(100, 42), true);
      eql(gt10.callCount, 1);
      eql(gt10.args[0], [100, 42]);
      eql(even.callCount, 1);
      eql(even.args[0], [100, 42]);
      return eql(f(8), false);
    });
    it('wraps moar functions f, g, h and invokes both with &&', function() {
      var f;
      f = aand(gt10, even, lt102);
      eql(f(100, 42), true);
      eql(gt10.callCount, 1);
      eql(gt10.args[0], [100, 42]);
      eql(even.callCount, 1);
      eql(even.args[0], [100, 42]);
      eql(lt102.callCount, 1);
      eql(lt102.args[0], [100, 42]);
      return eql(f(102), false);
    });
    it('is lazy', function() {
      var f, f1, f2;
      f1 = spy(function() {
        return false;
      });
      f2 = spy(function() {
        return true;
      });
      f = aand(f1, f2);
      eql(f(), false);
      eql(f1.callCount, 1);
      return eql(f2.callCount, 0);
    });
    return it('is aliased', function() {
      return assert.ok(F.and === F.aand);
    });
  });

  describe('or', function() {
    var even, gt10, lt102;
    gt10 = even = lt102 = null;
    beforeEach(function() {
      gt10 = spy(gt(10));
      even = spy(function(n) {
        return n % 2 === 0;
      });
      return lt102 = spy(lt(102));
    });
    it('is of arity(2)', function() {
      return eql(arity(oor), 2);
    });
    it('wraps two functions f, g and invokes both with ||', function() {
      var f;
      f = oor(gt10, even);
      eql(f(8, 42), true);
      eql(gt10.callCount, 1);
      eql(gt10.args[0], [8, 42]);
      eql(even.callCount, 1);
      eql(even.args[0], [8, 42]);
      return eql(f(9), false);
    });
    it('wraps moar functions f, g, h and invokes both with ||', function() {
      var f;
      f = oor(gt10, even, lt102);
      eql(f(9, 42), true);
      eql(gt10.args, [[9, 42]]);
      eql(even.args, [[9, 42]]);
      return eql(lt102.args, [[9, 42]]);
    });
    it('is lazy', function() {
      var f, f1, f2;
      f1 = spy(function() {
        return true;
      });
      f2 = spy(function() {
        return false;
      });
      f = oor(f1, f2);
      eql(f(), true);
      eql(f1.callCount, 1);
      return eql(f2.callCount, 0);
    });
    return it('is aliased', function() {
      return assert.ok(F.or === F.oor);
    });
  });

  describe('not', function() {
    var gt10;
    gt10 = null;
    beforeEach(function() {
      return gt10 = spy(gt(10));
    });
    it('is of arity(2)', function() {
      return eql(arity(nnot), 2);
    });
    it('wraps a function and nots the output', function() {
      var f;
      f = nnot(gt10);
      eql(f(12), false);
      eql(gt10.callCount, 1);
      return eql(gt10.args[0], [12]);
    });
    return it('is aliased', function() {
      return assert.ok(F.not === F.nnot);
    });
  });

  describe('chainable', function() {
    it('makes chainable functions for arity == 1', function() {
      var f, g;
      f = function(a) {
        return a + 14;
      };
      chainable('f', f);
      g = div(2).f;
      return eql(g(100), 64);
    });
    it('makes chainable functions for arity >= 2', function() {
      var f, g;
      f = function(a, b) {
        if (a === 42) {
          return b;
        } else {
          return 0;
        }
      };
      chainable('guard42', f);
      g = div(2).guard42(17);
      eql(g(100), 0);
      return eql(g(84), 17);
    });
    it('wants arity >= 1', function() {
      return assert["throw"]((function() {
        return chainable('fail', function() {});
      }), 'No chainable for arity 0');
    });
    return it('can redefine a chainable', function() {
      var f1, f2, g;
      f1 = function(a) {
        return 0;
      };
      chainable('f', f1);
      f2 = function(b) {
        return 1;
      };
      chainable('f', f2);
      g = add(3).f;
      return eql(g(4), 1);
    });
  });

  describe('eql', function() {
    return TYPES.forEach(function(v1, i1) {
      return TYPES.forEach(function(v2, i2) {
        var s1, s2;
        s1 = JSON.stringify(v1.v);
        s2 = JSON.stringify(v2.v);
        if (i1 === i2) {
          return it("equals for " + s1 + ", " + s2, function() {
            return eql(F.eql(v1.v, v2.v), true);
          });
        } else {
          return it("not equals for " + s1 + ", " + s2, function() {
            return eql(F.eql(v1.v, v2.v), false);
          });
        }
      });
    });
  });

  describe('groupby', function() {
    it('is is arity 2', function() {
      return eql(arity(groupby), 2);
    });
    it('groups objects according to key function', function() {
      var as, fn, gs;
      as = [
        {
          n: 'apa'
        }, {
          n: 'banan'
        }, {
          n: 'ananas'
        }
      ];
      fn = compose(take(1), get('n'));
      gs = groupby(as, fn);
      return eql(gs, {
        a: [
          {
            n: 'apa'
          }, {
            n: 'ananas'
          }
        ],
        b: [
          {
            n: 'banan'
          }
        ]
      });
    });
    it('handles empty', function() {
      return eql(groupby([], function() {}), {});
    });
    return it('is curried', function() {
      var as, fn, gs;
      as = [
        {
          n: 'apa'
        }
      ];
      fn = compose(take(1), get('n'));
      gs = groupby(fn)(as);
      return eql(gs, {
        a: [
          {
            n: 'apa'
          }
        ]
      });
    });
  });

  describe('tuple', function() {
    var jst;
    jst = JSON.stringify;
    it('creates a tuple from 2 args', function() {
      var t;
      t = tuple(22, 23);
      return eql(jst(t), '{"0":22,"1":23}');
    });
    it('creates a tuple from 3 args', function() {
      var t;
      t = tuple(22, 23, 24);
      return eql(jst(t), '{"0":22,"1":23,"2":24}');
    });
    it('is arity 2', function() {
      return eql(arity(tuple), 2);
    });
    it('is curried', function() {
      var f, t;
      f = tuple(23);
      t = f(22);
      return eql(jst(t), '{"0":22,"1":23}');
    });
    it('is vararg curried', function() {
      var f, t;
      f = tuple(24);
      t = f(22, 23);
      return eql(jst(t), '{"0":22,"1":23,"2":24}');
    });
    it('unpacks with fst', function() {
      var t;
      t = tuple(22, 23, 24);
      return eql(fst(t), 22);
    });
    it('unpacks with snd', function() {
      var t;
      t = tuple(22, 23, 24);
      return eql(snd(t), 23);
    });
    it('unpacks with nth', function() {
      var t;
      t = tuple(22, 23, 24);
      return eql(nth(2)(t), 24);
    });
    it('unpacks with length for len', function() {
      var t;
      t = tuple(22, 23);
      eql(len(t), 2);
      t = tuple(22, 23, 24);
      return eql(len(t), 3);
    });
    it('deep equals with eql', function() {
      var t1, t2;
      t1 = tuple([
        {
          a: 1
        }
      ], {
        c: [2]
      });
      t2 = tuple([
        {
          a: 1
        }
      ], {
        c: [2]
      });
      assert.ok(F.eql(t1, t2));
      t1 = tuple([
        {
          a: 1
        }
      ], tuple(2, 3));
      t2 = tuple([
        {
          a: 1
        }
      ], tuple(2, 3));
      assert.ok(F.eql(t1, t2));
      t1 = tuple([
        {
          a: 1
        }
      ], tuple(2, 3), 3);
      t2 = tuple([
        {
          a: 1
        }
      ], tuple(2, 3));
      return assert.ok(!F.eql(t1, t2));
    });
    return describe('unpack', function() {
      it('unpacks to function', function() {
        var t;
        t = tuple(1, 2, 3);
        return eql(unpack(t, function() {
          var as;
          as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return as;
        }), [1, 2, 3]);
      });
      it('is arity 2', function() {
        return eql(arity(unpack), 2);
      });
      return it('is curried', function() {
        var f, t;
        t = tuple(1, 2, 3);
        f = unpack(function() {
          var as;
          as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return as;
        });
        return eql(f(t), [1, 2, 3]);
      });
    });
  });

  describe('zip', function() {
    describe('based on generic zipwith', function() {
      it('is arity 3', function() {
        return eql(arity(zipwith), 3);
      });
      it('is curried', function() {
        var f, r;
        f = zipwith(add);
        r = f([1, 2], [3, 4]);
        return eql(r, [4, 6]);
      });
      it('is vararg curried', function() {
        var f, r;
        f = zipwith(add);
        r = f([1, 2], [3, 4], [5, 6]);
        return eql(r, [9, 12]);
      });
      return it('works for strings', function() {
        var r;
        r = zipwith(function() {
          var as;
          as = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return join(as, '-');
        })('ab', 'de');
        return eql(r, ['a-d', 'b-e']);
      });
    });
    return describe('to tuples', function() {
      it('is an array of tuples', function() {
        var r;
        r = zip([1, 2], [3, 4]);
        eql(type(r), 'array');
        eql(type(r[0]), 'tuple');
        return eql(r.toString(), '[tuple {"0":1,"1":3}],[tuple {"0":2,"1":4}]');
      });
      it('is arity 2', function() {
        return eql(arity(zip), 2);
      });
      it('is curried', function() {
        var r, z;
        z = zip([3, 4]);
        r = z([1, 2]);
        return eql(r.toString(), '[tuple {"0":1,"1":3}],[tuple {"0":2,"1":4}]');
      });
      it('is vararg curried', function() {
        var r, z;
        z = zip([5, 6]);
        r = z([1, 2], [3, 4]);
        return eql(r.toString(), '[tuple {"0":1,"1":3,"2":5}],[tuple {"0":2,"1":4,"2":6}]');
      });
      it('handles strings', function() {
        var r;
        r = zip('ab', 'de');
        return eql(r.toString(), '[tuple {"0":"a","1":"d"}],[tuple {"0":"b","1":"e"}]');
      });
      return describe('unzips with unzip', function() {
        it('is arity 1', function() {
          return eql(arity(unzip), 1);
        });
        it('goes backwards to tuple', function() {
          var r, u;
          r = zip([1, 2], [3, 4]);
          u = unzip(r);
          eql(type(u), 'tuple');
          eql(fst(u), [1, 2]);
          return eql(snd(u), [3, 4]);
        });
        return it('is vararg number of zipped tuples', function() {
          var r, u;
          r = zip([1, 2], [3, 4], [5, 6]);
          u = unzip(r);
          eql(type(u), 'tuple');
          eql(fst(u), [1, 2]);
          eql(snd(u), [3, 4]);
          return eql(nth(2)(u), [5, 6]);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=fnuc-test.js.map
